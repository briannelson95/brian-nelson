/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "./node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var e=__webpack_require__(/*! groq */ \"./node_modules/groq/lib/groq.js\"),r=__webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\"),t=__webpack_require__(/*! throttle-debounce */ \"./node_modules/throttle-debounce/cjs/index.js\"),n=__webpack_require__(/*! groq-js */ \"./node_modules/groq-js/dist/1.umd.cjs\"),o=__webpack_require__(/*! mendoza */ \"./node_modules/mendoza/lib/esm/index.js\");function i(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}var u=/*#__PURE__*/i(e),s=/*#__PURE__*/i(r);function a(){return a=Object.assign?Object.assign.bind():function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},a.apply(this,arguments)}var c,f=function(e,r,t){(function(e){return\"undefined\"!=typeof window&&e.addEventListener===window.EventSource.prototype.addEventListener})(e)&&e.addEventListener(r,t,!1),e.addEventListener(r,t)};function d(e,r,t){var n,o=r.token,i=new e(\"https://\"+r.projectId+\".api.sanity.io/v1/data/listen/\"+r.dataset+\"?query=*&effectFormat=mendoza\",{withCredentials:!0,headers:o?{Authorization:\"Bearer \"+o}:void 0});return f(i,\"welcome\",t.open),f(i,\"mutation\",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)})),f(i,\"channelError\",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error(\"Unknown error parsing listener message\"))}t.error(new Error(r.message||r.error||\"Listener returned HTTP \"+r.statusCode))}),f(i,\"error\",function(e){var r=\"undefined\"!=typeof window&&window.location.origin,n=r?\", and that the CORS-origin (\"+r+\") is allowed\":\"\",o=function(e){return\"object\"==typeof e&&null!==e&&\"message\"in e}(e)?\" (\"+e.message+\")\":\"\";t.error(new Error(\"Error establishing listener - check that the project ID and dataset are correct\"+n+o))}),{unsubscribe:function(){return Promise.resolve(i.close())}}}function v(e){return e._id.startsWith(\"drafts.\")?e._id.slice(7):e._id}function l(e,r){var t=a({},e);return delete t._rev,o.applyPatch(t,r)}function h(){return Promise.resolve()}function m(e,r,t){if(!e.s){if(t instanceof p){if(!t.s)return void(t.o=m.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(m.bind(null,e,r),m.bind(null,e,2));e.s=r,e.v=t;const n=e.o;n&&n(e)}}var p=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{m(n,1,i(this.v))}catch(e){m(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?m(n,1,r?r(o):o):t?m(n,1,t(o)):m(n,2,o)}catch(e){m(n,2,e)}},n},e}();function w(e){return e instanceof p&&1&e.s}var b=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch(\"https://\"+r+\".api.sanity.io/v1/data/export/\"+t,{credentials:\"include\",headers:n?{Authorization:\"Bearer \"+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error(\"Failed to read body from response\");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u=\"\";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var a=(u+=i.decode(s.value,{stream:!0})).split(\"\\n\"),c=0;c<a.length-1;++c){var f=a[c].trim();if(0!==f.length)try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=a[a.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body),u=i.getReader(),s=[],a=function(e,r){var t;do{var n=e();if(n&&n.then){if(!w(n)){t=!0;break}n=n.v}var o=r();if(w(o)&&(o=o.v),!o)return n}while(!o.then);var i=new p,u=m.bind(null,i,2);return(t?n.then(s):o.then(a)).then(void 0,u),i;function s(t){for(n=t;w(o=r())&&(o=o.v),o;){if(o.then)return void o.then(a).then(void 0,u);if((n=e())&&n.then){if(!w(n))return void n.then(s).then(void 0,u);n=n.v}}m(i,1,n)}function a(t){if(t){do{if((n=e())&&n.then){if(!w(n))return void n.then(s).then(void 0,u);n=n.v}if(w(t=r())&&(t=t.v),!t)return void m(i,1,n)}while(!t.then);t.then(a).then(void 0,u)}else m(i,1,n)}}(function(){return Promise.resolve(u.read()).then(function(e){if(function(e){return!!e&&\"error\"in e&&\"object\"==typeof e.error&&null!==e.error&&\"description\"in e.error&&\"string\"==typeof e.error.description&&!(\"_id\"in e)}(n=(t=e).value))throw new Error(\"Error streaming dataset: \"+n.error);if(n&&!n._id.startsWith(\"_.\")&&s.push(n),o&&s.length>o)throw u.cancel(\"Reached document limit\"),new Error(\"Error streaming dataset: Reached limit of \"+o+\" documents\")})},function(){return!t.done});return a&&a.then?a.then(function(e){return s}):s}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error(\"Error streaming dataset: \"+(\"object\"==typeof(r=e)&&\"error\"in r&&\"message\"in r?r.message||r.error:\"<unknown error>\"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};Object.defineProperty(exports, \"groq\", ({enumerable:!0,get:function(){return u.default}})),exports.groqStore=function(e){var r;!function(){var e=[\"EventSource\",\"ReadableStream\",\"fetch\"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error(\"Browser not supported. Missing browser APIs: \"+e.join(\", \"))}();var o=null!=(r=e.EventSource)?r:window.EventSource;if(e.token&&o===window.EventSource)throw new Error(\"When`token` option is used, `EventSource` option must also be provided. EventSource cannot be `window.EventSource`, as it does not support passing a token.\");return function(e,r){var o,i=function(e,r){return Promise.resolve(f()).then(function(){var t=n.parse(e,{params:r});return Promise.resolve(n.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})},f=function(){try{return o||(o=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,u=e.dataset,s=e.overlayDrafts,c=e.documentLimit,f=e.token;if(!e.listen)return{unsubscribe:h,loaded:n({projectId:i,dataset:u,documentLimit:c,token:f}).then(S).then(h)};var m,p,w,b,g,y,E=new Map,P=[],j=new Promise(function(e,r){p=e,w=r});return{unsubscribe:d(o,e,{next:function(e){m?(function(e){if(e.effects&&!e.documentId.startsWith(\"_.\")){var r=E.get(e.documentId)||null;!function(e,r){var t=E.get(e),n=m||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),E.set(e,r)):r?(n.splice(o,1,r),E.set(e,r)):(n.splice(o,1),E.delete(e))}(e.documentId,l(r,e.effects.apply))}}(e),function(e,r){clearTimeout(y),g!==r.transactionId&&b?(S(b),g=void 0):(g=r.transactionId,b=e.slice()),y=setTimeout(S,25,e.slice())}(m,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:u,documentLimit:c,token:f})).then(function(e){(m=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=l(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn(\"Received mutation for missing document %s\",t)}),e}(e,P)).forEach(function(e){return E.set(e._id,e)}),S(m),p()})}catch(e){return Promise.reject(e)}},error:function(e){return w(e)}}).unsubscribe,loaded:j};function S(e){b=void 0,y=void 0,g=void 0,r(s?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(v(e));e._id.startsWith(\"drafts.\")?r.set(v(e),function(e){return a({},e,{_id:v(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},r)),Promise.resolve(o.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=t.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return i(e.query,e.params).then(function(r){\"previousResult\"in e&&s.default(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:i,getDocument:function(e){return Promise.resolve(f()).then(function(){return i(u.default(c||(r=[\"*[_id == $id][0]\"],t||(t=r.slice(0)),r.raw=t,c=r)),{id:e});var r,t})},getDocuments:function(e){return Promise.resolve(f()).then(function(){var r=e.map(function(e){return'*[_id == \"'+e+'\"][0]'}).join(\",\\n\");return i(\"[\"+r+\"]\")})},subscribe:function(r,t,n){if(!e.listen)throw new Error(\"Cannot use `subscribe()` without `listen: true`\");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),o?o.unsubscribe():Promise.resolve()}}}(e,{EventSource:o,getDocuments:b})};\n//# sourceMappingURL=groq-store.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ncm9xLXN0b3JlL2Rpc3QvYnJvd3Nlci9ncm9xLXN0b3JlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sbUJBQU8sQ0FBQyw2Q0FBTSxJQUFJLG1CQUFPLENBQUMsZ0VBQWlCLElBQUksbUJBQU8sQ0FBQyx3RUFBbUIsSUFBSSxtQkFBTyxDQUFDLHNEQUFTLElBQUksbUJBQU8sQ0FBQyx3REFBUyxFQUFFLGNBQWMsK0NBQStDLFdBQVcsNENBQTRDLGFBQWEsd0RBQXdELFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHlCQUF5Qix3QkFBd0IsYUFBYSxxR0FBcUcsMERBQTBELGtCQUFrQiwySEFBMkgsOEJBQThCLDBCQUEwQixRQUFRLEVBQUUsa0VBQWtFLE1BQU0sSUFBSSxxQkFBcUIsU0FBUyxPQUFPLEtBQUssa0NBQWtDLE1BQU0sVUFBVSxJQUFJLHFCQUFxQixTQUFTLHlFQUF5RSwrRUFBK0UsMEJBQTBCLDhIQUE4SCxrREFBa0QsMEJBQTBCLDBHQUEwRyxHQUFHLHVCQUF1QixvQ0FBb0MsY0FBYyx3REFBd0QsZ0JBQWdCLFVBQVUsSUFBSSx1Q0FBdUMsYUFBYSx5QkFBeUIsa0JBQWtCLFNBQVMsbUJBQW1CLDBDQUEwQyxtQkFBbUIsbUVBQW1FLFlBQVksWUFBWSxTQUFTLDhCQUE4QixjQUFjLHNDQUFzQyxxQkFBcUIsTUFBTSxjQUFjLE1BQU0sSUFBSSxpQkFBaUIsU0FBUyxTQUFTLFNBQVMsWUFBWSwwQkFBMEIsSUFBSSxVQUFVLDZDQUE2QyxTQUFTLFVBQVUsR0FBRyxHQUFHLEdBQUcsY0FBYyw2QkFBNkIsa0JBQWtCLDBEQUEwRCxJQUFJLDhFQUE4RSxpQ0FBaUMsMEJBQTBCLFFBQVEsb0JBQW9CLGNBQWMsc0JBQXNCLDJEQUEyRCxXQUFXLGFBQWEsbUJBQW1CLDJCQUEyQixrQkFBa0IsZ0JBQWdCLDJCQUEyQiw0QkFBNEIsSUFBSSxrSkFBa0osZ0NBQWdDLFVBQVUsbUJBQW1CLGFBQWEsS0FBSyxrQkFBa0Isb0JBQW9CLHlCQUF5QixTQUFTLHlDQUF5QywrQ0FBK0Msb0JBQW9CLElBQUksaURBQWlELEtBQUssRUFBRSxTQUFTLFlBQVksb0NBQW9DLGVBQWUsV0FBVyxFQUFFLG9EQUFvRCxVQUFVLFNBQVMsMEJBQTBCLG9CQUFvQixrQkFBa0IsRUFBRSxVQUFVLEVBQUUsOENBQThDLE1BQU0sR0FBRyxVQUFVLGNBQWMsVUFBVSxLQUFLLE1BQU0sTUFBTSxVQUFVLDZCQUE2QixlQUFlLCtCQUErQiwrQ0FBK0MsY0FBYyxRQUFRLG9CQUFvQixFQUFFLCtDQUErQyxvQkFBb0IsOENBQThDLE9BQU8sU0FBUyxjQUFjLE1BQU0sR0FBRyxvQkFBb0IsOENBQThDLE1BQU0sNkNBQTZDLGVBQWUseUJBQXlCLGVBQWUsWUFBWSxrREFBa0QsZUFBZSw4SUFBOEkscUVBQXFFLHVLQUF1SyxFQUFFLFlBQVksY0FBYyxFQUFFLG9DQUFvQyxTQUFTLElBQUksaUJBQWlCLG9FQUFvRSxzSUFBc0ksTUFBTSxFQUFFLEdBQUcsK0JBQStCLEVBQUUsU0FBUywyQkFBMkIsd0NBQXFDLENBQUMsNkJBQTZCLGtCQUFrQixFQUFDLENBQUMsaUJBQWlCLGFBQWEsTUFBTSxZQUFZLGtFQUFrRSxxQkFBcUIsRUFBRSw0RkFBNEYsR0FBRyxtREFBbUQsa05BQWtOLHFCQUFxQixzQkFBc0IsNENBQTRDLGlCQUFpQixTQUFTLEVBQUUscUNBQXFDLG1CQUFtQixvQkFBb0IsZUFBZSxFQUFFLEVBQUUsY0FBYyxJQUFJLDZCQUE2Qiw2R0FBNkcsb0JBQW9CLHdCQUF3Qiw4Q0FBOEMsbUJBQW1CLDJEQUEyRCxRQUFRLEVBQUUsT0FBTyxtQkFBbUIsaUJBQWlCLGVBQWUsOENBQThDLGdDQUFnQyxlQUFlLDJDQUEyQyw0RkFBNEYscUNBQXFDLGtCQUFrQixvSEFBb0gsaUJBQWlCLGlCQUFpQixJQUFJLDBCQUEwQiw4Q0FBOEMsb0JBQW9CLGlCQUFpQixjQUFjLDZCQUE2Qiw4QkFBOEIsZ0NBQWdDLDBCQUEwQix5QkFBeUIsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLHNCQUFzQixtRUFBbUUsNkJBQTZCLGlFQUFpRSxJQUFJLDJCQUEyQixzQkFBc0IsV0FBVyxFQUFFLFNBQVMsMEJBQTBCLG1CQUFtQixhQUFhLHdCQUF3QixjQUFjLDJDQUEyQyxjQUFjLDZCQUE2QixrQkFBa0IsbURBQW1ELFdBQVcsSUFBSSxTQUFTLEVBQUUsdUJBQXVCLHlCQUF5QixRQUFRLGVBQWUsUUFBUSxnREFBZ0QsRUFBRSxTQUFTLDBCQUEwQiwyREFBMkQsYUFBYSxPQUFPLGNBQWMsNENBQTRDLCtGQUErRixvQkFBb0IsY0FBYyxFQUFFLE9BQU8sZ0NBQWdDLDRDQUE0QywrRUFBK0UsS0FBSyxFQUFFLFFBQVEsRUFBRSwwQkFBMEIsNENBQTRDLHdCQUF3Qiw2QkFBNkIsY0FBYyxvQkFBb0IsRUFBRSwyQkFBMkIsZ0ZBQWdGLE9BQU8sNkJBQTZCLFVBQVUsU0FBUyxhQUFhLHVCQUF1Qiw4REFBOEQsa0JBQWtCLHdEQUF3RCxJQUFJLDZCQUE2QjtBQUN6NFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9kaXN0L2Jyb3dzZXIvZ3JvcS1zdG9yZS5qcz9iOTExIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlPXJlcXVpcmUoXCJncm9xXCIpLHI9cmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKSx0PXJlcXVpcmUoXCJ0aHJvdHRsZS1kZWJvdW5jZVwiKSxuPXJlcXVpcmUoXCJncm9xLWpzXCIpLG89cmVxdWlyZShcIm1lbmRvemFcIik7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lOntkZWZhdWx0OmV9fXZhciB1PS8qI19fUFVSRV9fKi9pKGUpLHM9LyojX19QVVJFX18qL2kocik7ZnVuY3Rpb24gYSgpe3JldHVybiBhPU9iamVjdC5hc3NpZ24/T2JqZWN0LmFzc2lnbi5iaW5kKCk6ZnVuY3Rpb24oZSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIHQ9YXJndW1lbnRzW3JdO2Zvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKX1yZXR1cm4gZX0sYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGMsZj1mdW5jdGlvbihlLHIsdCl7KGZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJmUuYWRkRXZlbnRMaXN0ZW5lcj09PXdpbmRvdy5FdmVudFNvdXJjZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcn0pKGUpJiZlLmFkZEV2ZW50TGlzdGVuZXIocix0LCExKSxlLmFkZEV2ZW50TGlzdGVuZXIocix0KX07ZnVuY3Rpb24gZChlLHIsdCl7dmFyIG4sbz1yLnRva2VuLGk9bmV3IGUoXCJodHRwczovL1wiK3IucHJvamVjdElkK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9saXN0ZW4vXCIrci5kYXRhc2V0K1wiP3F1ZXJ5PSomZWZmZWN0Rm9ybWF0PW1lbmRvemFcIix7d2l0aENyZWRlbnRpYWxzOiEwLGhlYWRlcnM6bz97QXV0aG9yaXphdGlvbjpcIkJlYXJlciBcIitvfTp2b2lkIDB9KTtyZXR1cm4gZihpLFwid2VsY29tZVwiLHQub3BlbiksZihpLFwibXV0YXRpb25cIiwobj10Lm5leHQsZnVuY3Rpb24oZSl7dmFyIHI7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybn1uKHIpfSkpLGYoaSxcImNoYW5uZWxFcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByO2kuY2xvc2UoKTt0cnl7cj1KU09OLnBhcnNlKGUuZGF0YSl9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgdC5lcnJvcihuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yIHBhcnNpbmcgbGlzdGVuZXIgbWVzc2FnZVwiKSl9dC5lcnJvcihuZXcgRXJyb3Ioci5tZXNzYWdlfHxyLmVycm9yfHxcIkxpc3RlbmVyIHJldHVybmVkIEhUVFAgXCIrci5zdGF0dXNDb2RlKSl9KSxmKGksXCJlcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5sb2NhdGlvbi5vcmlnaW4sbj1yP1wiLCBhbmQgdGhhdCB0aGUgQ09SUy1vcmlnaW4gKFwiK3IrXCIpIGlzIGFsbG93ZWRcIjpcIlwiLG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm1lc3NhZ2VcImluIGV9KGUpP1wiIChcIitlLm1lc3NhZ2UrXCIpXCI6XCJcIjt0LmVycm9yKG5ldyBFcnJvcihcIkVycm9yIGVzdGFibGlzaGluZyBsaXN0ZW5lciAtIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgSUQgYW5kIGRhdGFzZXQgYXJlIGNvcnJlY3RcIituK28pKX0pLHt1bnN1YnNjcmliZTpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5jbG9zZSgpKX19fWZ1bmN0aW9uIHYoZSl7cmV0dXJuIGUuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP2UuX2lkLnNsaWNlKDcpOmUuX2lkfWZ1bmN0aW9uIGwoZSxyKXt2YXIgdD1hKHt9LGUpO3JldHVybiBkZWxldGUgdC5fcmV2LG8uYXBwbHlQYXRjaCh0LHIpfWZ1bmN0aW9uIGgoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gbShlLHIsdCl7aWYoIWUucyl7aWYodCBpbnN0YW5jZW9mIHApe2lmKCF0LnMpcmV0dXJuIHZvaWQodC5vPW0uYmluZChudWxsLGUscikpOzEmciYmKHI9dC5zKSx0PXQudn1pZih0JiZ0LnRoZW4pcmV0dXJuIHZvaWQgdC50aGVuKG0uYmluZChudWxsLGUsciksbS5iaW5kKG51bGwsZSwyKSk7ZS5zPXIsZS52PXQ7Y29uc3Qgbj1lLm87biYmbihlKX19dmFyIHA9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihyLHQpe3ZhciBuPW5ldyBlLG89dGhpcy5zO2lmKG8pe3ZhciBpPTEmbz9yOnQ7aWYoaSl7dHJ5e20obiwxLGkodGhpcy52KSl9Y2F0Y2goZSl7bShuLDIsZSl9cmV0dXJuIG59cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIG89ZS52OzEmZS5zP20obiwxLHI/cihvKTpvKTp0P20obiwxLHQobykpOm0obiwyLG8pfWNhdGNoKGUpe20obiwyLGUpfX0sbn0sZX0oKTtmdW5jdGlvbiB3KGUpe3JldHVybiBlIGluc3RhbmNlb2YgcCYmMSZlLnN9dmFyIGI9ZnVuY3Rpb24oZSl7dmFyIHI9ZS5wcm9qZWN0SWQsdD1lLmRhdGFzZXQsbj1lLnRva2VuLG89ZS5kb2N1bWVudExpbWl0O3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZldGNoKFwiaHR0cHM6Ly9cIityK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9leHBvcnQvXCIrdCx7Y3JlZGVudGlhbHM6XCJpbmNsdWRlXCIsaGVhZGVyczpuP3tBdXRob3JpemF0aW9uOlwiQmVhcmVyIFwiK259OnZvaWQgMH0pKS50aGVuKGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIocil7dmFyIHQsbixpPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZWFkIGJvZHkgZnJvbSByZXNwb25zZVwiKTt2YXIgcix0PSExO2Z1bmN0aW9uIG4oKXt0PSEwLHImJnIuY2FuY2VsKCl9cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQ6ZnVuY3Rpb24obyl7cj1lLmdldFJlYWRlcigpO3ZhciBpPW5ldyBUZXh0RGVjb2Rlcix1PVwiXCI7ci5yZWFkKCkudGhlbihmdW5jdGlvbiBlKHMpe3RyeXtpZihzLmRvbmUpcmV0dXJuIHQ/UHJvbWlzZS5yZXNvbHZlKCk6MD09PSh1PXUudHJpbSgpKS5sZW5ndGg/KG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk6KG8uZW5xdWV1ZShKU09OLnBhcnNlKHUpKSxvLmNsb3NlKCksUHJvbWlzZS5yZXNvbHZlKCkpO2Zvcih2YXIgYT0odSs9aS5kZWNvZGUocy52YWx1ZSx7c3RyZWFtOiEwfSkpLnNwbGl0KFwiXFxuXCIpLGM9MDtjPGEubGVuZ3RoLTE7KytjKXt2YXIgZj1hW2NdLnRyaW0oKTtpZigwIT09Zi5sZW5ndGgpdHJ5e28uZW5xdWV1ZShKU09OLnBhcnNlKGYpKX1jYXRjaChlKXtyZXR1cm4gby5lcnJvcihlKSxuKCksUHJvbWlzZS5yZXNvbHZlKCl9fWlmKHU9YVthLmxlbmd0aC0xXSwhcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7dmFyIGQ9ZnVuY3Rpb24odCxuKXt0cnl7dmFyIG89UHJvbWlzZS5yZXNvbHZlKHIucmVhZCgpKS50aGVuKGZ1bmN0aW9uKHIpe2Uocil9KX1jYXRjaChlKXtyZXR1cm4gbihlKX1yZXR1cm4gbyYmby50aGVuP28udGhlbih2b2lkIDAsbik6b30oMCxmdW5jdGlvbihlKXtvLmVycm9yKGUpfSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShkJiZkLnRoZW4/ZC50aGVuKGZ1bmN0aW9uKCl7fSk6dm9pZCAwKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSkuY2F0Y2goZnVuY3Rpb24oZSl7cmV0dXJuIG8uZXJyb3IoZSl9KX0sY2FuY2VsOm59KX0oZS5ib2R5KSx1PWkuZ2V0UmVhZGVyKCkscz1bXSxhPWZ1bmN0aW9uKGUscil7dmFyIHQ7ZG97dmFyIG49ZSgpO2lmKG4mJm4udGhlbil7aWYoIXcobikpe3Q9ITA7YnJlYWt9bj1uLnZ9dmFyIG89cigpO2lmKHcobykmJihvPW8udiksIW8pcmV0dXJuIG59d2hpbGUoIW8udGhlbik7dmFyIGk9bmV3IHAsdT1tLmJpbmQobnVsbCxpLDIpO3JldHVybih0P24udGhlbihzKTpvLnRoZW4oYSkpLnRoZW4odm9pZCAwLHUpLGk7ZnVuY3Rpb24gcyh0KXtmb3Iobj10O3cobz1yKCkpJiYobz1vLnYpLG87KXtpZihvLnRoZW4pcmV0dXJuIHZvaWQgby50aGVuKGEpLnRoZW4odm9pZCAwLHUpO2lmKChuPWUoKSkmJm4udGhlbil7aWYoIXcobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fX1tKGksMSxuKX1mdW5jdGlvbiBhKHQpe2lmKHQpe2Rve2lmKChuPWUoKSkmJm4udGhlbil7aWYoIXcobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fWlmKHcodD1yKCkpJiYodD10LnYpLCF0KXJldHVybiB2b2lkIG0oaSwxLG4pfXdoaWxlKCF0LnRoZW4pO3QudGhlbihhKS50aGVuKHZvaWQgMCx1KX1lbHNlIG0oaSwxLG4pfX0oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUucmVhZCgpKS50aGVuKGZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKGUpe3JldHVybiEhZSYmXCJlcnJvclwiaW4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUuZXJyb3ImJm51bGwhPT1lLmVycm9yJiZcImRlc2NyaXB0aW9uXCJpbiBlLmVycm9yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5lcnJvci5kZXNjcmlwdGlvbiYmIShcIl9pZFwiaW4gZSl9KG49KHQ9ZSkudmFsdWUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIituLmVycm9yKTtpZihuJiYhbi5faWQuc3RhcnRzV2l0aChcIl8uXCIpJiZzLnB1c2gobiksbyYmcy5sZW5ndGg+byl0aHJvdyB1LmNhbmNlbChcIlJlYWNoZWQgZG9jdW1lbnQgbGltaXRcIiksbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFJlYWNoZWQgbGltaXQgb2YgXCIrbytcIiBkb2N1bWVudHNcIil9KX0sZnVuY3Rpb24oKXtyZXR1cm4hdC5kb25lfSk7cmV0dXJuIGEmJmEudGhlbj9hLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHN9KTpzfXZhciB0PWZ1bmN0aW9uKCl7aWYoMjAwIT09ZS5zdGF0dXMpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlLmpzb24oKSkudGhlbihmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogXCIrKFwib2JqZWN0XCI9PXR5cGVvZihyPWUpJiZcImVycm9yXCJpbiByJiZcIm1lc3NhZ2VcImluIHI/ci5tZXNzYWdlfHxyLmVycm9yOlwiPHVua25vd24gZXJyb3I+XCIpKTt2YXIgcn0pfSgpO3JldHVybiB0JiZ0LnRoZW4/dC50aGVuKHIpOnIoKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiZ3JvcVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlZmF1bHR9fSksZXhwb3J0cy5ncm9xU3RvcmU9ZnVuY3Rpb24oZSl7dmFyIHI7IWZ1bmN0aW9uKCl7dmFyIGU9W1wiRXZlbnRTb3VyY2VcIixcIlJlYWRhYmxlU3RyZWFtXCIsXCJmZXRjaFwiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIShlIGluIHdpbmRvdyl9KTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgbm90IHN1cHBvcnRlZC4gTWlzc2luZyBicm93c2VyIEFQSXM6IFwiK2Uuam9pbihcIiwgXCIpKX0oKTt2YXIgbz1udWxsIT0ocj1lLkV2ZW50U291cmNlKT9yOndpbmRvdy5FdmVudFNvdXJjZTtpZihlLnRva2VuJiZvPT09d2luZG93LkV2ZW50U291cmNlKXRocm93IG5ldyBFcnJvcihcIldoZW5gdG9rZW5gIG9wdGlvbiBpcyB1c2VkLCBgRXZlbnRTb3VyY2VgIG9wdGlvbiBtdXN0IGFsc28gYmUgcHJvdmlkZWQuIEV2ZW50U291cmNlIGNhbm5vdCBiZSBgd2luZG93LkV2ZW50U291cmNlYCwgYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBwYXNzaW5nIGEgdG9rZW4uXCIpO3JldHVybiBmdW5jdGlvbihlLHIpe3ZhciBvLGk9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3ZhciB0PW4ucGFyc2UoZSx7cGFyYW1zOnJ9KTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4uZXZhbHVhdGUodCx7ZGF0YXNldDptLHBhcmFtczpyfSkpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0KCl9KX0pfSxmPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBvfHwobz1mdW5jdGlvbihlLHIsdCl7dmFyIG49dC5nZXREb2N1bWVudHMsbz10LkV2ZW50U291cmNlLGk9ZS5wcm9qZWN0SWQsdT1lLmRhdGFzZXQscz1lLm92ZXJsYXlEcmFmdHMsYz1lLmRvY3VtZW50TGltaXQsZj1lLnRva2VuO2lmKCFlLmxpc3RlbilyZXR1cm57dW5zdWJzY3JpYmU6aCxsb2FkZWQ6bih7cHJvamVjdElkOmksZGF0YXNldDp1LGRvY3VtZW50TGltaXQ6Yyx0b2tlbjpmfSkudGhlbihTKS50aGVuKGgpfTt2YXIgbSxwLHcsYixnLHksRT1uZXcgTWFwLFA9W10saj1uZXcgUHJvbWlzZShmdW5jdGlvbihlLHIpe3A9ZSx3PXJ9KTtyZXR1cm57dW5zdWJzY3JpYmU6ZChvLGUse25leHQ6ZnVuY3Rpb24oZSl7bT8oZnVuY3Rpb24oZSl7aWYoZS5lZmZlY3RzJiYhZS5kb2N1bWVudElkLnN0YXJ0c1dpdGgoXCJfLlwiKSl7dmFyIHI9RS5nZXQoZS5kb2N1bWVudElkKXx8bnVsbDshZnVuY3Rpb24oZSxyKXt2YXIgdD1FLmdldChlKSxuPW18fFtdLG89dD9uLmluZGV4T2YodCk6LTE7LTE9PT1vJiZyPyhuLnB1c2gociksRS5zZXQoZSxyKSk6cj8obi5zcGxpY2UobywxLHIpLEUuc2V0KGUscikpOihuLnNwbGljZShvLDEpLEUuZGVsZXRlKGUpKX0oZS5kb2N1bWVudElkLGwocixlLmVmZmVjdHMuYXBwbHkpKX19KGUpLGZ1bmN0aW9uKGUscil7Y2xlYXJUaW1lb3V0KHkpLGchPT1yLnRyYW5zYWN0aW9uSWQmJmI/KFMoYiksZz12b2lkIDApOihnPXIudHJhbnNhY3Rpb25JZCxiPWUuc2xpY2UoKSkseT1zZXRUaW1lb3V0KFMsMjUsZS5zbGljZSgpKX0obSxlKSk6UC5wdXNoKGUpfSxvcGVuOmZ1bmN0aW9uKCl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUobih7cHJvamVjdElkOmksZGF0YXNldDp1LGRvY3VtZW50TGltaXQ6Yyx0b2tlbjpmfSkpLnRoZW4oZnVuY3Rpb24oZSl7KG09ZnVuY3Rpb24oZSxyKXt2YXIgdD1uZXcgTWFwO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9dC5nZXQoZS5kb2N1bWVudElkKXx8W107ci5wdXNoKGUpLHQuc2V0KGUuZG9jdW1lbnRJZCxyKX0pLHQuZm9yRWFjaChmdW5jdGlvbihyLHQpe3ZhciBuPWUuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5faWQ9PT10fSk7aWYobil7dmFyIG89ITEsaT1uO3IuZm9yRWFjaChmdW5jdGlvbihlKXsobz1vfHxlLnByZXZpb3VzUmV2PT09bi5fcmV2KSYmZS5lZmZlY3RzJiYoaT1sKGksZS5lZmZlY3RzLmFwcGx5KSl9KSxlLnNwbGljZShlLmluZGV4T2YobiksMSxpKX1lbHNlIGNvbnNvbGUud2FybihcIlJlY2VpdmVkIG11dGF0aW9uIGZvciBtaXNzaW5nIGRvY3VtZW50ICVzXCIsdCl9KSxlfShlLFApKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBFLnNldChlLl9pZCxlKX0pLFMobSkscCgpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sZXJyb3I6ZnVuY3Rpb24oZSl7cmV0dXJuIHcoZSl9fSkudW5zdWJzY3JpYmUsbG9hZGVkOmp9O2Z1bmN0aW9uIFMoZSl7Yj12b2lkIDAseT12b2lkIDAsZz12b2lkIDAscihzP2Z1bmN0aW9uKGUpe3ZhciByPW5ldyBNYXA7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yLmdldCh2KGUpKTtlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9yLnNldCh2KGUpLGZ1bmN0aW9uKGUpe3JldHVybiBhKHt9LGUse19pZDp2KGUpfSl9KGUpKTp0fHxyLnNldChlLl9pZCxlKX0pLEFycmF5LmZyb20oci52YWx1ZXMoKSl9KGUpOmUpfX0oZSxmdW5jdGlvbihlKXttPWUscCgpfSxyKSksUHJvbWlzZS5yZXNvbHZlKG8ubG9hZGVkKS50aGVuKGZ1bmN0aW9uKCl7fSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sbT1bXSxwPXQudGhyb3R0bGUoZS5zdWJzY3JpcHRpb25UaHJvdHRsZU1zfHw1MCxmdW5jdGlvbigpe3cuZm9yRWFjaChiKX0pLHc9W107ZnVuY3Rpb24gYihlKXtyZXR1cm4gaShlLnF1ZXJ5LGUucGFyYW1zKS50aGVuKGZ1bmN0aW9uKHIpe1wicHJldmlvdXNSZXN1bHRcImluIGUmJnMuZGVmYXVsdChlLnByZXZpb3VzUmVzdWx0LHIpfHwoZS5wcmV2aW91c1Jlc3VsdD1yLGUuY2FsbGJhY2sodm9pZCAwLHIpKX0pLmNhdGNoKGZ1bmN0aW9uKHIpe2UuY2FsbGJhY2socil9KX1yZXR1cm57cXVlcnk6aSxnZXREb2N1bWVudDpmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBpKHUuZGVmYXVsdChjfHwocj1bXCIqW19pZCA9PSAkaWRdWzBdXCJdLHR8fCh0PXIuc2xpY2UoMCkpLHIucmF3PXQsYz1yKSkse2lkOmV9KTt2YXIgcix0fSl9LGdldERvY3VtZW50czpmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3ZhciByPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybicqW19pZCA9PSBcIicrZSsnXCJdWzBdJ30pLmpvaW4oXCIsXFxuXCIpO3JldHVybiBpKFwiW1wiK3IrXCJdXCIpfSl9LHN1YnNjcmliZTpmdW5jdGlvbihyLHQsbil7aWYoIWUubGlzdGVuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYHN1YnNjcmliZSgpYCB3aXRob3V0IGBsaXN0ZW46IHRydWVgXCIpO3ZhciBvPXtxdWVyeTpyLHBhcmFtczp0LGNhbGxiYWNrOm59O3cucHVzaChvKTt2YXIgaT0hMTtyZXR1cm4gYihvKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gaXx8KGk9ITAsdy5zcGxpY2Uody5pbmRleE9mKG8pLDEpKSxQcm9taXNlLnJlc29sdmUoKX19fSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBwLmNhbmNlbCgpLG8/by51bnN1YnNjcmliZSgpOlByb21pc2UucmVzb2x2ZSgpfX19KGUse0V2ZW50U291cmNlOm8sZ2V0RG9jdW1lbnRzOmJ9KX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm9xLXN0b3JlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@sanity/groq-store/dist/browser/groq-store.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!*************************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; },\n/* harmony export */   \"getType\": function() { return /* binding */ getType; },\n/* harmony export */   \"rebaseValue\": function() { return /* binding */ rebaseValue; },\n/* harmony export */   \"unwrap\": function() { return /* binding */ unwrap; },\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = /** @class */ (function () {\n    function Model(meta) {\n        this.meta = meta;\n    }\n    Model.prototype.wrap = function (data) {\n        return this.wrapWithMeta(data, this.meta, this.meta);\n    };\n    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {\n        if (endMeta === void 0) { endMeta = this.meta; }\n        return { data: data, startMeta: startMeta, endMeta: endMeta };\n    };\n    Model.prototype.asObject = function (value) {\n        if (!value.content) {\n            var fields = {};\n            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\n            }\n            value.content = { type: 'object', fields: fields };\n        }\n        return value.content;\n    };\n    Model.prototype.asArray = function (value) {\n        var _this = this;\n        if (!value.content) {\n            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });\n            var metas = elements.map(function () { return _this.meta; });\n            value.content = { type: 'array', elements: elements, metas: metas };\n        }\n        return value.content;\n    };\n    Model.prototype.asString = function (value) {\n        if (!value.content) {\n            var str = value.data;\n            var part = {\n                value: str,\n                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),\n                uses: [],\n                startMeta: value.startMeta,\n                endMeta: value.endMeta\n            };\n            value.content = this.stringFromParts([part]);\n        }\n        return value.content;\n    };\n    Model.prototype.stringFromParts = function (parts) {\n        var str = {\n            type: 'string',\n            parts: parts\n        };\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            part.uses.push(str);\n        }\n        return str;\n    };\n    Model.prototype.objectGetKeys = function (value) {\n        if (value.content) {\n            return Object.keys(value.content.fields);\n        }\n        else {\n            return Object.keys(value.data);\n        }\n    };\n    Model.prototype.objectGetField = function (value, key) {\n        var obj = this.asObject(value);\n        return obj.fields[key];\n    };\n    Model.prototype.arrayGetElement = function (value, idx) {\n        var arr = this.asArray(value);\n        return arr.elements[idx];\n    };\n    Model.prototype.finalize = function (content) {\n        this.updateEndMeta(content);\n        return { content: content, startMeta: this.meta, endMeta: this.meta };\n    };\n    Model.prototype.markChanged = function (value) {\n        return this.wrap(unwrap(value));\n    };\n    Model.prototype.updateEndMeta = function (content) {\n        if (content.type == 'string') {\n            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {\n                var part = _a[_i];\n                part.endMeta = this.meta;\n            }\n        }\n        else {\n            if (content.type === 'array') {\n                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {\n                    var val = _c[_b];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n            else {\n                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {\n                    var val = _e[_d];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n        }\n    };\n    Model.prototype.copyString = function (value) {\n        if (value) {\n            var other = this.asString(value);\n            return this.stringFromParts(other.parts.slice());\n        }\n        else {\n            return {\n                type: 'string',\n                parts: []\n            };\n        }\n    };\n    Model.prototype.copyObject = function (value) {\n        var obj = {\n            type: 'object',\n            fields: {}\n        };\n        if (value) {\n            var other = this.asObject(value);\n            Object.assign(obj.fields, other.fields);\n        }\n        return obj;\n    };\n    Model.prototype.copyArray = function (value) {\n        var arr = value ? this.asArray(value) : null;\n        var elements = arr ? arr.elements : [];\n        var metas = arr ? arr.metas : [];\n        return {\n            type: 'array',\n            elements: elements,\n            metas: metas\n        };\n    };\n    Model.prototype.objectSetField = function (target, key, value) {\n        target.fields[key] = value;\n    };\n    Model.prototype.objectDeleteField = function (target, key) {\n        delete target.fields[key];\n    };\n    Model.prototype.arrayAppendValue = function (target, value) {\n        target.elements.push(value);\n        target.metas.push(this.meta);\n    };\n    Model.prototype.arrayAppendSlice = function (target, source, left, right) {\n        var _a, _b;\n        var arr = this.asArray(source);\n        var samePosition = arr.elements.length === left;\n        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));\n        if (samePosition) {\n            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));\n        }\n        else {\n            for (var i = left; i < right; i++) {\n                target.metas.push(this.meta);\n            }\n        }\n    };\n    Model.prototype.stringAppendValue = function (target, value) {\n        var str = this.asString(value);\n        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {\n            var part = _a[_i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    Model.prototype.stringAppendPart = function (target, part) {\n        target.parts.push(part);\n        part.uses.push(target);\n    };\n    Model.prototype.resolveStringPart = function (str, from, len) {\n        if (len === 0)\n            return from;\n        for (var i = from; i < str.parts.length; i++) {\n            var part = str.parts[i];\n            if (len === part.utf8size) {\n                // Matches perfect!\n                return i + 1;\n            }\n            if (len < part.utf8size) {\n                // It's a part of this chunk. We now need to split it up.\n                this.splitString(part, len);\n                return i + 1;\n            }\n            len -= part.utf8size;\n        }\n        throw new Error('splitting string out of bounds');\n    };\n    Model.prototype.splitString = function (part, idx) {\n        var leftValue;\n        var rightValue;\n        var leftSize = idx;\n        var rightSize = part.utf8size - leftSize;\n        // idx is here in UTF-8 index, not codepoint index.\n        // This means we might to adjust for multi-byte characters.\n        if (part.utf8size !== part.value.length) {\n            var byteCount = 0;\n            for (idx = 0; byteCount < leftSize; idx++) {\n                var code = part.value.codePointAt(idx);\n                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);\n                if (size === 4)\n                    idx++; // Surrogate pair.\n                byteCount += size;\n            }\n        }\n        leftValue = part.value.slice(0, idx);\n        rightValue = part.value.slice(idx);\n        var newPart = {\n            value: rightValue,\n            utf8size: rightSize,\n            uses: part.uses.slice(),\n            startMeta: part.startMeta,\n            endMeta: part.endMeta\n        };\n        part.value = leftValue;\n        part.utf8size = leftSize;\n        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {\n            var use = _a[_i];\n            // Insert the new part.\n            var idx_1 = use.parts.indexOf(part);\n            if (idx_1 === -1)\n                throw new Error('bug: mismatch between string parts and use.');\n            use.parts.splice(idx_1 + 1, 0, newPart);\n        }\n    };\n    Model.prototype.stringAppendSlice = function (target, source, left, right) {\n        var str = this.asString(source);\n        var firstPart = this.resolveStringPart(str, 0, left);\n        var lastPart = this.resolveStringPart(str, firstPart, right - left);\n        for (var i = firstPart; i < lastPart; i++) {\n            var part = str.parts[i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    return Model;\n}());\n// Turns a native JavaScript object into a Value with a given origin.\nfunction wrap(data, meta) {\n    return { data: data, startMeta: meta, endMeta: meta };\n}\n// Converts a Value into a native JavaScript type.\nfunction unwrap(value) {\n    if (typeof value.data !== 'undefined')\n        return value.data;\n    var result;\n    var content = value.content;\n    switch (content.type) {\n        case 'string':\n            result = content.parts.map(function (part) { return part.value; }).join('');\n            break;\n        case 'array':\n            result = content.elements.map(function (val) { return unwrap(val); });\n            break;\n        case 'object': {\n            result = {};\n            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                result[key] = unwrap(val);\n            }\n        }\n    }\n    value.data = result;\n    return result;\n}\n// Returns the type of a Value.\nfunction getType(value) {\n    if (value.content)\n        return value.content.type;\n    if (Array.isArray(value.data))\n        return 'array';\n    if (value.data === null)\n        return 'null';\n    return typeof value.data;\n}\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\nfunction rebaseValue(left, right) {\n    var leftType = getType(left);\n    var rightType = getType(right);\n    if (leftType !== rightType)\n        return right;\n    var leftModel = new Model(left.endMeta);\n    var rightModel = new Model(right.endMeta);\n    switch (leftType) {\n        case 'object': {\n            var leftObj = leftModel.asObject(left);\n            var rightObj = rightModel.asObject(right);\n            // Number of fields which are identical in left and right.\n            var identicalFieldCount = 0;\n            var leftFieldCount = Object.keys(leftObj.fields).length;\n            var rightFieldCount = Object.keys(rightObj.fields).length;\n            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], rightVal = _b[1];\n                var leftVal = leftObj.fields[key];\n                if (leftVal) {\n                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n                    if (rightObj.fields[key] === leftVal) {\n                        identicalFieldCount++;\n                    }\n                }\n            }\n            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n            return isIdentical ? left : right;\n        }\n        case 'array': {\n            var leftArr = leftModel.asArray(left);\n            var rightArr = rightModel.asArray(right);\n            if (leftArr.elements.length !== rightArr.elements.length) {\n                break;\n            }\n            var numRebased = 0;\n            for (var i = 0; i < rightArr.elements.length; i++) {\n                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n                if (rightArr.elements[i] !== leftArr.elements[i]) {\n                    numRebased++;\n                }\n            }\n            return numRebased === 0 ? left : right;\n        }\n        case 'null':\n        case 'boolean':\n        case 'number': {\n            if (unwrap(left) === unwrap(right))\n                return left;\n            break;\n        }\n        case 'string': {\n            var leftRaw = unwrap(left);\n            var rightRaw = unwrap(right);\n            if (leftRaw === rightRaw)\n                return left;\n            var result = rightModel.copyString(null);\n            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);\n            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);\n            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);\n            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);\n            if (0 < prefix) {\n                rightModel.stringAppendSlice(result, left, 0, prefix);\n            }\n            if (prefix < rightLen - suffix) {\n                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n            }\n            if (leftLen - suffix < leftLen) {\n                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n            }\n            var value = rightModel.finalize(result);\n            if (unwrap(value) !== rightRaw)\n                throw new Error('incorrect string rebase');\n            return value;\n        }\n    }\n    return right;\n}\nfunction applyPatch(left, patch, startMeta) {\n    var model = new Model(startMeta);\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=incremental-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QztBQUNxQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtREFBbUQ7QUFDL0csbURBQW1ELG9CQUFvQjtBQUN2RSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0EsMkJBQTJCLG1EQUFZO0FBQ3ZDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1EQUFZO0FBQ3JDLHlCQUF5QixtREFBWTtBQUNyQywyQkFBMkIscURBQWM7QUFDekMsMEJBQTBCLHFEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanM/ZTZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRjaGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1wYXRjaGVyJztcbmltcG9ydCB7IHV0ZjhjaGFyU2l6ZSwgdXRmOHN0cmluZ1NpemUsIGNvbW1vblByZWZpeCwgY29tbW9uU3VmZml4IH0gZnJvbSAnLi91dGY4JztcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlbChtZXRhKSB7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgfVxuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcFdpdGhNZXRhKGRhdGEsIHRoaXMubWV0YSwgdGhpcy5tZXRhKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwV2l0aE1ldGEgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnRNZXRhLCBlbmRNZXRhKSB7XG4gICAgICAgIGlmIChlbmRNZXRhID09PSB2b2lkIDApIHsgZW5kTWV0YSA9IHRoaXMubWV0YTsgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBzdGFydE1ldGE6IHN0YXJ0TWV0YSwgZW5kTWV0YTogZW5kTWV0YSB9O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlLmRhdGEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gdGhpcy53cmFwV2l0aE1ldGEodmFsLCB2YWx1ZS5zdGFydE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUuY29udGVudCA9IHsgdHlwZTogJ29iamVjdCcsIGZpZWxkczogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHZhbHVlLmRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy53cmFwV2l0aE1ldGEoaXRlbSwgdmFsdWUuc3RhcnRNZXRhKTsgfSk7XG4gICAgICAgICAgICB2YXIgbWV0YXMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWV0YTsgfSk7XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiAnYXJyYXknLCBlbGVtZW50czogZWxlbWVudHMsIG1ldGFzOiBtZXRhcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgICAgICAgIHV0ZjhzaXplOiB1dGY4c3RyaW5nU2l6ZShzdHIpLFxuICAgICAgICAgICAgICAgIHVzZXM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0TWV0YTogdmFsdWUuc3RhcnRNZXRhLFxuICAgICAgICAgICAgICAgIGVuZE1ldGE6IHZhbHVlLmVuZE1ldGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0gdGhpcy5zdHJpbmdGcm9tUGFydHMoW3BhcnRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdGcm9tUGFydHMgPSBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgdmFyIHN0ciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgcGFydHM6IHBhcnRzXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzXzFbX2ldO1xuICAgICAgICAgICAgcGFydC51c2VzLnB1c2goc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdEdldEtleXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5jb250ZW50LmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RHZXRGaWVsZCA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iai5maWVsZHNba2V5XTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUdldEVsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5hc0FycmF5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFyci5lbGVtZW50c1tpZHhdO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4geyBjb250ZW50OiBjb250ZW50LCBzdGFydE1ldGE6IHRoaXMubWV0YSwgZW5kTWV0YTogdGhpcy5tZXRhIH07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUubWFya0NoYW5nZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh1bndyYXAodmFsdWUpKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS51cGRhdGVFbmRNZXRhID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRlbnQucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgcGFydC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBjb250ZW50LmVsZW1lbnRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gT2JqZWN0LnZhbHVlcyhjb250ZW50LmZpZWxkcyk7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmNvcHlTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhvdGhlci5wYXJ0cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgcGFydHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBmaWVsZHM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9iai5maWVsZHMsIG90aGVyLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5QXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGFyciA9IHZhbHVlID8gdGhpcy5hc0FycmF5KHZhbHVlKSA6IG51bGw7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGFyciA/IGFyci5lbGVtZW50cyA6IFtdO1xuICAgICAgICB2YXIgbWV0YXMgPSBhcnIgPyBhcnIubWV0YXMgOiBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBtZXRhczogbWV0YXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RTZXRGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmZpZWxkc1trZXldID0gdmFsdWU7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldC5maWVsZHNba2V5XTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmVsZW1lbnRzLnB1c2godmFsdWUpO1xuICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkoc291cmNlKTtcbiAgICAgICAgdmFyIHNhbWVQb3NpdGlvbiA9IGFyci5lbGVtZW50cy5sZW5ndGggPT09IGxlZnQ7XG4gICAgICAgIChfYSA9IHRhcmdldC5lbGVtZW50cykucHVzaC5hcHBseShfYSwgYXJyLmVsZW1lbnRzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIGlmIChzYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAgIChfYiA9IHRhcmdldC5tZXRhcykucHVzaC5hcHBseShfYiwgYXJyLm1ldGFzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVmdDsgaSA8IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nQXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdHIucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nQXBwZW5kUGFydCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcnQpIHtcbiAgICAgICAgdGFyZ2V0LnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIHBhcnQudXNlcy5wdXNoKHRhcmdldCk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUucmVzb2x2ZVN0cmluZ1BhcnQgPSBmdW5jdGlvbiAoc3RyLCBmcm9tLCBsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmcm9tO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICAgICAgICBpZiAobGVuID09PSBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBwZXJmZWN0IVxuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW4gPCBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHBhcnQgb2YgdGhpcyBjaHVuay4gV2Ugbm93IG5lZWQgdG8gc3BsaXQgaXQgdXAuXG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZyhwYXJ0LCBsZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiAtPSBwYXJ0LnV0ZjhzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXR0aW5nIHN0cmluZyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3BsaXRTdHJpbmcgPSBmdW5jdGlvbiAocGFydCwgaWR4KSB7XG4gICAgICAgIHZhciBsZWZ0VmFsdWU7XG4gICAgICAgIHZhciByaWdodFZhbHVlO1xuICAgICAgICB2YXIgbGVmdFNpemUgPSBpZHg7XG4gICAgICAgIHZhciByaWdodFNpemUgPSBwYXJ0LnV0ZjhzaXplIC0gbGVmdFNpemU7XG4gICAgICAgIC8vIGlkeCBpcyBoZXJlIGluIFVURi04IGluZGV4LCBub3QgY29kZXBvaW50IGluZGV4LlxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIG1pZ2h0IHRvIGFkanVzdCBmb3IgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAocGFydC51dGY4c2l6ZSAhPT0gcGFydC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBieXRlQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChpZHggPSAwOyBieXRlQ291bnQgPCBsZWZ0U2l6ZTsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHBhcnQudmFsdWUuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gNClcbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7IC8vIFN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgcmlnaHRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoaWR4KTtcbiAgICAgICAgdmFyIG5ld1BhcnQgPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmlnaHRWYWx1ZSxcbiAgICAgICAgICAgIHV0ZjhzaXplOiByaWdodFNpemUsXG4gICAgICAgICAgICB1c2VzOiBwYXJ0LnVzZXMuc2xpY2UoKSxcbiAgICAgICAgICAgIHN0YXJ0TWV0YTogcGFydC5zdGFydE1ldGEsXG4gICAgICAgICAgICBlbmRNZXRhOiBwYXJ0LmVuZE1ldGFcbiAgICAgICAgfTtcbiAgICAgICAgcGFydC52YWx1ZSA9IGxlZnRWYWx1ZTtcbiAgICAgICAgcGFydC51dGY4c2l6ZSA9IGxlZnRTaXplO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcGFydC51c2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHVzZSA9IF9hW19pXTtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IHBhcnQuXG4gICAgICAgICAgICB2YXIgaWR4XzEgPSB1c2UucGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgIGlmIChpZHhfMSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWc6IG1pc21hdGNoIGJldHdlZW4gc3RyaW5nIHBhcnRzIGFuZCB1c2UuJyk7XG4gICAgICAgICAgICB1c2UucGFydHMuc3BsaWNlKGlkeF8xICsgMSwgMCwgbmV3UGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuYXNTdHJpbmcoc291cmNlKTtcbiAgICAgICAgdmFyIGZpcnN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCAwLCBsZWZ0KTtcbiAgICAgICAgdmFyIGxhc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIGZpcnN0UGFydCwgcmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0UGFydDsgaSA8IGxhc3RQYXJ0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNb2RlbDtcbn0oKSk7XG4vLyBUdXJucyBhIG5hdGl2ZSBKYXZhU2NyaXB0IG9iamVjdCBpbnRvIGEgVmFsdWUgd2l0aCBhIGdpdmVuIG9yaWdpbi5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKGRhdGEsIG1ldGEpIHtcbiAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBzdGFydE1ldGE6IG1ldGEsIGVuZE1ldGE6IG1ldGEgfTtcbn1cbi8vIENvbnZlcnRzIGEgVmFsdWUgaW50byBhIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5kYXRhICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgY29udGVudCA9IHZhbHVlLmNvbnRlbnQ7XG4gICAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQucGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnZhbHVlOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICByZXN1bHQgPSBjb250ZW50LmVsZW1lbnRzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB1bndyYXAodmFsKTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMoY29udGVudC5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUuZGF0YSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gUmV0dXJucyB0aGUgdHlwZSBvZiBhIFZhbHVlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29udGVudClcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQudHlwZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSlcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgaWYgKHZhbHVlLmRhdGEgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5kYXRhO1xufVxuLy8gVXBkYXRlcyB0aGUgYHJpZ2h0YCB2YWx1ZSBzdWNoIHRoYXQgaXQgcmV1c2VzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgYGxlZnRgIHZhbHVlLlxuZXhwb3J0IGZ1bmN0aW9uIHJlYmFzZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIGxlZnRUeXBlID0gZ2V0VHlwZShsZWZ0KTtcbiAgICB2YXIgcmlnaHRUeXBlID0gZ2V0VHlwZShyaWdodCk7XG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpXG4gICAgICAgIHJldHVybiByaWdodDtcbiAgICB2YXIgbGVmdE1vZGVsID0gbmV3IE1vZGVsKGxlZnQuZW5kTWV0YSk7XG4gICAgdmFyIHJpZ2h0TW9kZWwgPSBuZXcgTW9kZWwocmlnaHQuZW5kTWV0YSk7XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICB2YXIgbGVmdE9iaiA9IGxlZnRNb2RlbC5hc09iamVjdChsZWZ0KTtcbiAgICAgICAgICAgIHZhciByaWdodE9iaiA9IHJpZ2h0TW9kZWwuYXNPYmplY3QocmlnaHQpO1xuICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGZpZWxkcyB3aGljaCBhcmUgaWRlbnRpY2FsIGluIGxlZnQgYW5kIHJpZ2h0LlxuICAgICAgICAgICAgdmFyIGlkZW50aWNhbEZpZWxkQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGxlZnRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMobGVmdE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciByaWdodEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhyaWdodE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhyaWdodE9iai5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHJpZ2h0VmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRWYWwgPSBsZWZ0T2JqLmZpZWxkc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0T2JqLmZpZWxkc1trZXldID0gcmViYXNlVmFsdWUobGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRPYmouZmllbGRzW2tleV0gPT09IGxlZnRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWNhbEZpZWxkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0lkZW50aWNhbCA9IGxlZnRGaWVsZENvdW50ID09PSByaWdodEZpZWxkQ291bnQgJiYgbGVmdEZpZWxkQ291bnQgPT09IGlkZW50aWNhbEZpZWxkQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gaXNJZGVudGljYWwgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICAgICAgICB2YXIgbGVmdEFyciA9IGxlZnRNb2RlbC5hc0FycmF5KGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0QXJyID0gcmlnaHRNb2RlbC5hc0FycmF5KHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChsZWZ0QXJyLmVsZW1lbnRzLmxlbmd0aCAhPT0gcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtUmViYXNlZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpZ2h0QXJyLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRBcnIuZWxlbWVudHNbaV0gPSByZWJhc2VWYWx1ZShsZWZ0QXJyLmVsZW1lbnRzW2ldLCByaWdodEFyci5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0QXJyLmVsZW1lbnRzW2ldICE9PSBsZWZ0QXJyLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVJlYmFzZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtUmViYXNlZCA9PT0gMCA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgIGlmICh1bndyYXAobGVmdCkgPT09IHVud3JhcChyaWdodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICB2YXIgbGVmdFJhdyA9IHVud3JhcChsZWZ0KTtcbiAgICAgICAgICAgIHZhciByaWdodFJhdyA9IHVud3JhcChyaWdodCk7XG4gICAgICAgICAgICBpZiAobGVmdFJhdyA9PT0gcmlnaHRSYXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmlnaHRNb2RlbC5jb3B5U3RyaW5nKG51bGwpO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNvbW1vblByZWZpeChsZWZ0UmF3LCByaWdodFJhdyk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0TGVuID0gdXRmOHN0cmluZ1NpemUocmlnaHRSYXcpO1xuICAgICAgICAgICAgdmFyIGxlZnRMZW4gPSB1dGY4c3RyaW5nU2l6ZShsZWZ0UmF3KTtcbiAgICAgICAgICAgIGlmICgwIDwgcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIDAsIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlZml4IDwgcmlnaHRMZW4gLSBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgcmlnaHQsIHByZWZpeCwgcmlnaHRMZW4gLSBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRMZW4gLSBzdWZmaXggPCBsZWZ0TGVuKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIGxlZnRMZW4gLSBzdWZmaXgsIGxlZnRMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHVud3JhcCh2YWx1ZSkgIT09IHJpZ2h0UmF3KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb3JyZWN0IHN0cmluZyByZWJhc2UnKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmlnaHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCwgc3RhcnRNZXRhKSB7XG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHN0YXJ0TWV0YSk7XG4gICAgdmFyIHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihtb2RlbCwgbGVmdCwgcGF0Y2gpO1xuICAgIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY3JlbWVudGFsLXBhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/incremental-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; },\n/* harmony export */   \"incremental\": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ \"./node_modules/mendoza/lib/esm/incremental-patcher.js\");\n/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ \"./node_modules/mendoza/lib/esm/simple-patcher.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDZjtBQUNNO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW5kZXguanM/NGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpbmNyZW1lbnRhbF8xIGZyb20gJy4vaW5jcmVtZW50YWwtcGF0Y2hlcic7XG5leHBvcnQgeyBpbmNyZW1lbnRhbF8xIGFzIGluY3JlbWVudGFsIH07XG5leHBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSAnLi9zaW1wbGUtcGF0Y2hlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/internal-patcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Patcher\": function() { return /* binding */ Patcher; }\n/* harmony export */ });\nvar OPS = [\n    'Value',\n    'Copy',\n    'Blank',\n    'ReturnIntoArray',\n    'ReturnIntoObject',\n    'ReturnIntoObjectSameKey',\n    'PushField',\n    'PushElement',\n    'PushParent',\n    'Pop',\n    'PushFieldCopy',\n    'PushFieldBlank',\n    'PushElementCopy',\n    'PushElementBlank',\n    'ReturnIntoObjectPop',\n    'ReturnIntoObjectSameKeyPop',\n    'ReturnIntoArrayPop',\n    'ObjectSetFieldValue',\n    'ObjectCopyField',\n    'ObjectDeleteField',\n    'ArrayAppendValue',\n    'ArrayAppendSlice',\n    'StringAppendString',\n    'StringAppendSlice'\n];\nvar Patcher = /** @class */ (function () {\n    function Patcher(model, root, patch) {\n        this.i = 0;\n        this.inputStack = [];\n        this.outputStack = [];\n        this.model = model;\n        this.root = root;\n        this.patch = patch;\n    }\n    Patcher.prototype.read = function () {\n        return this.patch[this.i++];\n    };\n    Patcher.prototype.process = function () {\n        this.inputStack.push({ value: this.root });\n        this.outputStack.push({ value: this.root });\n        for (; this.i < this.patch.length;) {\n            var opcode = this.read();\n            var op = OPS[opcode];\n            if (!op)\n                throw new Error(\"Unknown opcode: \" + opcode);\n            var processor = \"process\" + op;\n            this[processor].apply(this);\n        }\n        var entry = this.outputStack.pop();\n        return this.finalizeOutput(entry);\n    };\n    Patcher.prototype.inputEntry = function () {\n        return this.inputStack[this.inputStack.length - 1];\n    };\n    Patcher.prototype.inputKey = function (entry, idx) {\n        if (!entry.keys) {\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\n        }\n        return entry.keys[idx];\n    };\n    Patcher.prototype.outputEntry = function () {\n        return this.outputStack[this.outputStack.length - 1];\n    };\n    Patcher.prototype.outputArray = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyArray(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputObject = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyObject(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputString = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyString(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.finalizeOutput = function (entry) {\n        if (entry.writeValue) {\n            return this.model.finalize(entry.writeValue);\n        }\n        else {\n            return entry.value;\n        }\n    };\n    // Processors:\n    Patcher.prototype.processValue = function () {\n        var value = this.model.wrap(this.read());\n        this.outputStack.push({ value: value });\n    };\n    Patcher.prototype.processCopy = function () {\n        var input = this.inputEntry();\n        this.outputStack.push({ value: input.value });\n    };\n    Patcher.prototype.processBlank = function () {\n        this.outputStack.push({ value: null });\n    };\n    Patcher.prototype.processReturnIntoArray = function () {\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, result);\n    };\n    Patcher.prototype.processReturnIntoObject = function () {\n        var key = this.read();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        result = this.model.markChanged(result);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, key, result);\n    };\n    Patcher.prototype.processReturnIntoObjectSameKey = function () {\n        var input = this.inputEntry();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, input.key, result);\n    };\n    Patcher.prototype.processPushField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var value = this.model.objectGetField(entry.value, key);\n        this.inputStack.push({ value: value, key: key });\n    };\n    Patcher.prototype.processPushElement = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var value = this.model.arrayGetElement(entry.value, idx);\n        this.inputStack.push({ value: value });\n    };\n    Patcher.prototype.processPop = function () {\n        this.inputStack.pop();\n    };\n    Patcher.prototype.processPushFieldCopy = function () {\n        this.processPushField();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushFieldBlank = function () {\n        this.processPushField();\n        this.processBlank();\n    };\n    Patcher.prototype.processPushElementCopy = function () {\n        this.processPushElement();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushElementBlank = function () {\n        this.processPushElement();\n        this.processBlank();\n    };\n    Patcher.prototype.processReturnIntoObjectPop = function () {\n        this.processReturnIntoObject();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoArrayPop = function () {\n        this.processReturnIntoArray();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectSetFieldValue = function () {\n        this.processValue();\n        this.processReturnIntoObject();\n    };\n    Patcher.prototype.processObjectCopyField = function () {\n        this.processPushField();\n        this.processCopy();\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectDeleteField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var obj = this.outputObject();\n        this.model.objectDeleteField(obj, key);\n    };\n    Patcher.prototype.processArrayAppendValue = function () {\n        var value = this.model.wrap(this.read());\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, value);\n    };\n    Patcher.prototype.processArrayAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputArray();\n        var val = this.inputEntry().value;\n        this.model.arrayAppendSlice(str, val, left, right);\n    };\n    Patcher.prototype.processStringAppendString = function () {\n        var value = this.model.wrap(this.read());\n        var str = this.outputString();\n        this.model.stringAppendValue(str, value);\n    };\n    Patcher.prototype.processStringAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputString();\n        var val = this.inputEntry().value;\n        this.model.stringAppendSlice(str, val, left, right);\n    };\n    return Patcher;\n}());\n\n//# sourceMappingURL=internal-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQsZ0NBQWdDLGtCQUFrQjtBQUNsRCxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNrQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanM/YjYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgT1BTID0gW1xuICAgICdWYWx1ZScsXG4gICAgJ0NvcHknLFxuICAgICdCbGFuaycsXG4gICAgJ1JldHVybkludG9BcnJheScsXG4gICAgJ1JldHVybkludG9PYmplY3QnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleScsXG4gICAgJ1B1c2hGaWVsZCcsXG4gICAgJ1B1c2hFbGVtZW50JyxcbiAgICAnUHVzaFBhcmVudCcsXG4gICAgJ1BvcCcsXG4gICAgJ1B1c2hGaWVsZENvcHknLFxuICAgICdQdXNoRmllbGRCbGFuaycsXG4gICAgJ1B1c2hFbGVtZW50Q29weScsXG4gICAgJ1B1c2hFbGVtZW50QmxhbmsnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0UG9wJyxcbiAgICAnUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AnLFxuICAgICdSZXR1cm5JbnRvQXJyYXlQb3AnLFxuICAgICdPYmplY3RTZXRGaWVsZFZhbHVlJyxcbiAgICAnT2JqZWN0Q29weUZpZWxkJyxcbiAgICAnT2JqZWN0RGVsZXRlRmllbGQnLFxuICAgICdBcnJheUFwcGVuZFZhbHVlJyxcbiAgICAnQXJyYXlBcHBlbmRTbGljZScsXG4gICAgJ1N0cmluZ0FwcGVuZFN0cmluZycsXG4gICAgJ1N0cmluZ0FwcGVuZFNsaWNlJ1xuXTtcbnZhciBQYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGNoZXIobW9kZWwsIHJvb3QsIHBhdGNoKSB7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgIH1cbiAgICBQYXRjaGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIGZvciAoOyB0aGlzLmkgPCB0aGlzLnBhdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHZhciBvcCA9IE9QU1tvcGNvZGVdO1xuICAgICAgICAgICAgaWYgKCFvcClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIgKyBvcGNvZGUpO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NvciA9IFwicHJvY2Vzc1wiICsgb3A7XG4gICAgICAgICAgICB0aGlzW3Byb2Nlc3Nvcl0uYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUuaW5wdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRTdGFja1t0aGlzLmlucHV0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEtleSA9IGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7XG4gICAgICAgIGlmICghZW50cnkua2V5cykge1xuICAgICAgICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5rZXlzW2lkeF07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0U3RhY2tbdGhpcy5vdXRwdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weUFycmF5KGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlPYmplY3QoZW50cnkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5maW5hbGl6ZU91dHB1dCA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFByb2Nlc3NvcnM6XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiBpbnB1dC52YWx1ZSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IG51bGwgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwubWFya0NoYW5nZWQocmVzdWx0KTtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwgaW5wdXQua2V5LCByZXN1bHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwub2JqZWN0R2V0RmllbGQoZW50cnkudmFsdWUsIGtleSk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBrZXk6IGtleSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5hcnJheUdldEVsZW1lbnQoZW50cnkudmFsdWUsIGlkeCk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1BvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hFbGVtZW50KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0U2V0RmllbGRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzVmFsdWUoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdENvcHlGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vYmplY3REZWxldGVGaWVsZChvYmosIGtleSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgICAgICB0aGlzLm1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0Y2hlcjtcbn0oKSk7XG5leHBvcnQgeyBQYXRjaGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC1wYXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/internal-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/simple-patcher.js":
/*!********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = {\n    wrap: function (data) {\n        return data;\n    },\n    finalize: function (b) {\n        if (Array.isArray(b)) {\n            return b;\n        }\n        else {\n            return b.data;\n        }\n    },\n    markChanged: function (value) {\n        return value;\n    },\n    objectGetKeys: function (value) {\n        return Object.keys(value);\n    },\n    objectGetField: function (value, key) {\n        return value[key];\n    },\n    arrayGetElement: function (value, idx) {\n        return value[idx];\n    },\n    copyObject: function (value) {\n        var res = {\n            type: 'object',\n            data: {}\n        };\n        if (value !== null) {\n            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                res.data[key] = val;\n            }\n        }\n        return res;\n    },\n    copyArray: function (value) {\n        if (value === null)\n            return [];\n        return value.slice();\n    },\n    copyString: function (value) {\n        return {\n            type: 'string',\n            data: value === null ? '' : value\n        };\n    },\n    objectSetField: function (target, key, value) {\n        target.data[key] = value;\n    },\n    objectDeleteField: function (target, key) {\n        delete target.data[key];\n    },\n    arrayAppendValue: function (target, value) {\n        target.push(value);\n    },\n    arrayAppendSlice: function (target, source, left, right) {\n        target.push.apply(target, source.slice(left, right));\n    },\n    stringAppendSlice: function (target, source, left, right) {\n        var sourceString = source;\n        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);\n        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);\n        target.data += sourceString.slice(leftPos, rightPos);\n    },\n    stringAppendValue: function (target, value) {\n        target.data += value;\n    }\n};\n// Applies a patch on a JavaScript object.\nfunction applyPatch(left, patch) {\n    var root = left; // No need to wrap because the representation is the same.\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=simple-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QztBQUNIO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQix1REFBZ0I7QUFDdEMsdUJBQXVCLHVEQUFnQjtBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQkFBcUI7QUFDckIsc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzPzY5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0Y2hlciB9IGZyb20gJy4vaW50ZXJuYWwtcGF0Y2hlcic7XG5pbXBvcnQgeyB1dGY4cmVzb2x2ZUluZGV4IH0gZnJvbSAnLi91dGY4JztcbnZhciBNb2RlbCA9IHtcbiAgICB3cmFwOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYi5kYXRhO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXJrQ2hhbmdlZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG9iamVjdEdldEtleXM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIH0sXG4gICAgb2JqZWN0R2V0RmllbGQ6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgIH0sXG4gICAgYXJyYXlHZXRFbGVtZW50OiBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICByZXR1cm4gdmFsdWVbaWR4XTtcbiAgICB9LFxuICAgIGNvcHlPYmplY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmVzLmRhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgY29weUFycmF5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9LFxuICAgIGNvcHlTdHJpbmc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZSA9PT0gbnVsbCA/ICcnIDogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdFNldEZpZWxkOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIG9iamVjdERlbGV0ZUZpZWxkOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldC5kYXRhW2tleV07XG4gICAgfSxcbiAgICBhcnJheUFwcGVuZFZhbHVlOiBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XG4gICAgfSxcbiAgICBhcnJheUFwcGVuZFNsaWNlOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRhcmdldC5wdXNoLmFwcGx5KHRhcmdldCwgc291cmNlLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgfSxcbiAgICBzdHJpbmdBcHBlbmRTbGljZTogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgc291cmNlU3RyaW5nID0gc291cmNlO1xuICAgICAgICB2YXIgbGVmdFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCBsZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIHJpZ2h0LCBsZWZ0UG9zKTtcbiAgICAgICAgdGFyZ2V0LmRhdGEgKz0gc291cmNlU3RyaW5nLnNsaWNlKGxlZnRQb3MsIHJpZ2h0UG9zKTtcbiAgICB9LFxuICAgIHN0cmluZ0FwcGVuZFZhbHVlOiBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcbiAgICB9XG59O1xuLy8gQXBwbGllcyBhIHBhdGNoIG9uIGEgSmF2YVNjcmlwdCBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCkge1xuICAgIHZhciByb290ID0gbGVmdDsgLy8gTm8gbmVlZCB0byB3cmFwIGJlY2F1c2UgdGhlIHJlcHJlc2VudGF0aW9uIGlzIHRoZSBzYW1lLlxuICAgIHZhciBwYXRjaGVyID0gbmV3IFBhdGNoZXIoTW9kZWwsIHJvb3QsIHBhdGNoKTtcbiAgICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGUtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/simple-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/utf8.js":
/*!**********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/utf8.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"commonPrefix\": function() { return /* binding */ commonPrefix; },\n/* harmony export */   \"commonSuffix\": function() { return /* binding */ commonSuffix; },\n/* harmony export */   \"utf8charSize\": function() { return /* binding */ utf8charSize; },\n/* harmony export */   \"utf8resolveIndex\": function() { return /* binding */ utf8resolveIndex; },\n/* harmony export */   \"utf8stringSize\": function() { return /* binding */ utf8stringSize; }\n/* harmony export */ });\nfunction utf8charSize(code) {\n    if (code >> 16) {\n        return 4;\n    }\n    else if (code >> 11) {\n        return 3;\n    }\n    else if (code >> 7) {\n        return 2;\n    }\n    else {\n        return 1;\n    }\n}\nfunction utf8stringSize(str) {\n    var b = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.codePointAt(i);\n        var size = utf8charSize(code);\n        if (size == 4)\n            i++;\n        b += size;\n    }\n    return b;\n}\n/** Converts an UTF-8 byte index into a UCS-2 index. */\nfunction utf8resolveIndex(str, idx, start) {\n    if (start === void 0) { start = 0; }\n    var byteCount = start;\n    var ucsIdx = 0;\n    for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n        var code = str.codePointAt(ucsIdx);\n        var size = utf8charSize(code);\n        if (size === 4)\n            ucsIdx++; // Surrogate pair.\n        byteCount += size;\n    }\n    return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n    var len = Math.min(str.length, str2.length);\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(i);\n        var bPoint = str2.codePointAt(i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nfunction commonSuffix(str, str2, prefix) {\n    if (prefix === void 0) { prefix = 0; }\n    var len = Math.min(str.length, str2.length) - prefix;\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(str.length - 1 - i);\n        var bPoint = str2.codePointAt(str2.length - 1 - i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanM/ZWM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcbiAgICBpZiAoY29kZSA+PiAxNikge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA+PiAxMSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA+PiA3KSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhzdHJpbmdTaXplKHN0cikge1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgICAgIGlmIChzaXplID09IDQpXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGIgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG4vKiogQ29udmVydHMgYW4gVVRGLTggYnl0ZSBpbmRleCBpbnRvIGEgVUNTLTIgaW5kZXguICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOHJlc29sdmVJbmRleChzdHIsIGlkeCwgc3RhcnQpIHtcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICB2YXIgYnl0ZUNvdW50ID0gc3RhcnQ7XG4gICAgdmFyIHVjc0lkeCA9IDA7XG4gICAgZm9yICh1Y3NJZHggPSBzdGFydDsgYnl0ZUNvdW50IDwgaWR4OyB1Y3NJZHgrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jb2RlUG9pbnRBdCh1Y3NJZHgpO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgaWYgKHNpemUgPT09IDQpXG4gICAgICAgICAgICB1Y3NJZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gdWNzSWR4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpO1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgdmFyIGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgdmFyIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgICAgICBiICs9IHNpemU7XG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25TdWZmaXgoc3RyLCBzdHIyLCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHsgcHJlZml4ID0gMDsgfVxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCkgLSBwcmVmaXg7XG4gICAgdmFyIGIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KHN0ci5sZW5ndGggLSAxIC0gaSk7XG4gICAgICAgIHZhciBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KHN0cjIubGVuZ3RoIC0gMSAtIGkpO1xuICAgICAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICAgICAgYiArPSBzaXplO1xuICAgICAgICBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/utf8.js\n"));

/***/ }),

/***/ "./node_modules/groq-js/dist/1.umd.cjs":
/*!*********************************************!*\
  !*** ./node_modules/groq-js/dist/1.umd.cjs ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function(g,f){ true?f(exports):0;})(this,(function(exports){'use strict';/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n    return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n\nfunction __generator(thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n}\n\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}var MarkProcessor = /** @class */ (function () {\n    function MarkProcessor(string, marks, parseOptions) {\n        this.allowBoost = false;\n        this.string = string;\n        this.marks = marks;\n        this.index = 0;\n        this.parseOptions = parseOptions;\n    }\n    MarkProcessor.prototype.hasMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.index + pos < this.marks.length;\n    };\n    MarkProcessor.prototype.getMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.marks[this.index + pos];\n    };\n    MarkProcessor.prototype.shift = function () {\n        this.index += 1;\n    };\n    MarkProcessor.prototype.process = function (visitor) {\n        var mark = this.marks[this.index];\n        this.shift();\n        var func = visitor[mark.name];\n        if (!func) {\n            throw new Error(\"Unknown handler: \".concat(mark.name));\n        }\n        return func.call(visitor, this, mark);\n    };\n    MarkProcessor.prototype.processString = function () {\n        this.shift();\n        return this.processStringEnd();\n    };\n    MarkProcessor.prototype.processStringEnd = function () {\n        var prev = this.marks[this.index - 1];\n        var curr = this.marks[this.index];\n        this.shift();\n        return this.string.slice(prev.position, curr.position);\n    };\n    MarkProcessor.prototype.slice = function (len) {\n        var pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    };\n    return MarkProcessor;\n}());var RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    if (RFC3339_REGEX.test(str)) {\n        return new Date(str);\n    }\n    return null;\n}\nfunction formatRFC3339(d) {\n    var year = addLeadingZero(d.getUTCFullYear(), 4);\n    var month = addLeadingZero(d.getUTCMonth() + 1, 2);\n    var day = addLeadingZero(d.getUTCDate(), 2);\n    var hour = addLeadingZero(d.getUTCHours(), 2);\n    var minute = addLeadingZero(d.getUTCMinutes(), 2);\n    var second = addLeadingZero(d.getUTCSeconds(), 2);\n    var fractionalSecond = '';\n    var millis = d.getMilliseconds();\n    if (millis != 0) {\n        fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n    }\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n    var str = num.toString();\n    while (str.length < targetLength) {\n        str = \"0\".concat(str);\n    }\n    return str;\n}function escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction pathRegExp(pattern) {\n    var re = [];\n    for (var _i = 0, _a = pattern.split('.'); _i < _a.length; _i++) {\n        var part = _a[_i];\n        if (part === '*') {\n            re.push('[^.]+');\n        }\n        else if (part === '**') {\n            re.push('.*');\n        }\n        else {\n            re.push(escapeRegExp(part));\n        }\n    }\n    return new RegExp(\"^\".concat(re.join('.'), \"$\"));\n}\nvar Path = /** @class */ (function () {\n    function Path(pattern) {\n        this.pattern = pattern;\n        this.patternRe = pathRegExp(pattern);\n    }\n    Path.prototype.matches = function (str) {\n        return this.patternRe.test(str);\n    };\n    Path.prototype.toJSON = function () {\n        return this.pattern;\n    };\n    return Path;\n}());var StreamValue = /** @class */ (function () {\n    function StreamValue(generator) {\n        this.type = 'stream';\n        this.generator = generator;\n        this.ticker = null;\n        this.isDone = false;\n        this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    StreamValue.prototype.isArray = function () {\n        return true;\n    };\n    StreamValue.prototype.get = function () {\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _b, _c, value, _d, _e, e_1_1;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        result = [];\n                        _f.label = 1;\n                    case 1:\n                        _f.trys.push([1, 7, 8, 13]);\n                        _b = __asyncValues(this);\n                        _f.label = 2;\n                    case 2: return [4 /*yield*/, _b.next()];\n                    case 3:\n                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 6];\n                        value = _c.value;\n                        _e = (_d = result).push;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _e.apply(_d, [_f.sent()]);\n                        _f.label = 5;\n                    case 5: return [3 /*break*/, 2];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_1_1 = _f.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _f.trys.push([8, , 11, 12]);\n                        if (!(_c && !_c.done && (_a = _b[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _a.call(_b)];\n                    case 9:\n                        _f.sent();\n                        _f.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    StreamValue.prototype[Symbol.asyncIterator] = function () {\n        return __asyncGenerator(this, arguments, function _a() {\n            var i;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        _b.label = 2;\n                    case 2:\n                        if (!(i < this.data.length)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, __await(this.data[i])];\n                    case 3: return [4 /*yield*/, _b.sent()];\n                    case 4:\n                        _b.sent();\n                        _b.label = 5;\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 2];\n                    case 6:\n                        if (!this.isDone) return [3 /*break*/, 8];\n                        return [4 /*yield*/, __await(void 0)];\n                    case 7: return [2 /*return*/, _b.sent()];\n                    case 8: return [4 /*yield*/, __await(this._nextTick())];\n                    case 9:\n                        _b.sent();\n                        return [3 /*break*/, 1];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    StreamValue.prototype._nextTick = function () {\n        var _this = this;\n        if (this.ticker) {\n            return this.ticker;\n        }\n        var currentResolver;\n        var setupTicker = function () {\n            _this.ticker = new Promise(function (resolve) {\n                currentResolver = resolve;\n            });\n        };\n        var tick = function () {\n            currentResolver();\n            setupTicker();\n        };\n        var fetch = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b, value, e_2_1;\n            var e_2, _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 5, 6, 11]);\n                        _a = __asyncValues(this.generator());\n                        _d.label = 1;\n                    case 1: return [4 /*yield*/, _a.next()];\n                    case 2:\n                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 4];\n                        value = _b.value;\n                        this.data.push(value);\n                        tick();\n                        _d.label = 3;\n                    case 3: return [3 /*break*/, 1];\n                    case 4: return [3 /*break*/, 11];\n                    case 5:\n                        e_2_1 = _d.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 11];\n                    case 6:\n                        _d.trys.push([6, , 9, 10]);\n                        if (!(_b && !_b.done && (_c = _a[\"return\"]))) return [3 /*break*/, 8];\n                        return [4 /*yield*/, _c.call(_a)];\n                    case 7:\n                        _d.sent();\n                        _d.label = 8;\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 10: return [7 /*endfinally*/];\n                    case 11:\n                        this.isDone = true;\n                        tick();\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        setupTicker();\n        fetch();\n        return this.ticker;\n    };\n    return StreamValue;\n}());var StaticValue = /** @class */ (function () {\n    function StaticValue(data, type) {\n        this.data = data;\n        this.type = type;\n    }\n    StaticValue.prototype.isArray = function () {\n        return this.type === 'array';\n    };\n    // eslint-disable-next-line require-await\n    StaticValue.prototype.get = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.data];\n            });\n        });\n    };\n    StaticValue.prototype[Symbol.asyncIterator] = function () {\n        if (Array.isArray(this.data)) {\n            return (function (data) {\n                var _i, data_1, element;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            _i = 0, data_1 = data;\n                            _a.label = 1;\n                        case 1:\n                            if (!(_i < data_1.length)) return [3 /*break*/, 4];\n                            element = data_1[_i];\n                            return [4 /*yield*/, fromJS(element)];\n                        case 2:\n                            _a.sent();\n                            _a.label = 3;\n                        case 3:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 4: return [2 /*return*/];\n                    }\n                });\n            })(this.data);\n        }\n        throw new Error(\"Cannot iterate over: \".concat(this.type));\n    };\n    return StaticValue;\n}());\nvar NULL_VALUE = new StaticValue(null, 'null');\nvar TRUE_VALUE = new StaticValue(true, 'boolean');\nvar FALSE_VALUE = new StaticValue(false, 'boolean');\nvar DateTime = /** @class */ (function () {\n    function DateTime(date) {\n        this.date = date;\n    }\n    DateTime.parseToValue = function (str) {\n        var date = parseRFC3339(str);\n        if (date) {\n            return new StaticValue(new DateTime(date), 'datetime');\n        }\n        return NULL_VALUE;\n    };\n    DateTime.prototype.equals = function (other) {\n        return this.date.getTime() == other.date.getTime();\n    };\n    DateTime.prototype.add = function (secs) {\n        var copy = new Date(this.date.getTime());\n        copy.setTime(copy.getTime() + secs * 1000);\n        return new DateTime(copy);\n    };\n    DateTime.prototype.difference = function (other) {\n        return (this.date.getTime() - other.date.getTime()) / 1000;\n    };\n    DateTime.prototype.compareTo = function (other) {\n        return this.date.getTime() - other.date.getTime();\n    };\n    DateTime.prototype.toString = function () {\n        return formatRFC3339(this.date);\n    };\n    DateTime.prototype.toJSON = function () {\n        return this.toString();\n    };\n    return DateTime;\n}());\nfunction fromNumber(num) {\n    if (Number.isFinite(num)) {\n        return new StaticValue(num, 'number');\n    }\n    return NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, 'string');\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, 'datetime');\n}\nfunction fromPath(path) {\n    return new StaticValue(path, 'path');\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next === 'function';\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction fromJS(val) {\n    if (isIterator(val)) {\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var val_1, val_1_1, value, e_1_1;\n                var e_1, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _b.trys.push([0, 7, 8, 13]);\n                            val_1 = __asyncValues(val);\n                            _b.label = 1;\n                        case 1: return [4 /*yield*/, __await(val_1.next())];\n                        case 2:\n                            if (!(val_1_1 = _b.sent(), !val_1_1.done)) return [3 /*break*/, 6];\n                            value = val_1_1.value;\n                            return [4 /*yield*/, __await(fromJS(value))];\n                        case 3: return [4 /*yield*/, _b.sent()];\n                        case 4:\n                            _b.sent();\n                            _b.label = 5;\n                        case 5: return [3 /*break*/, 1];\n                        case 6: return [3 /*break*/, 13];\n                        case 7:\n                            e_1_1 = _b.sent();\n                            e_1 = { error: e_1_1 };\n                            return [3 /*break*/, 13];\n                        case 8:\n                            _b.trys.push([8, , 11, 12]);\n                            if (!(val_1_1 && !val_1_1.done && (_a = val_1[\"return\"]))) return [3 /*break*/, 10];\n                            return [4 /*yield*/, __await(_a.call(val_1))];\n                        case 9:\n                            _b.sent();\n                            _b.label = 10;\n                        case 10: return [3 /*break*/, 12];\n                        case 11:\n                            if (e_1) throw e_1.error;\n                            return [7 /*endfinally*/];\n                        case 12: return [7 /*endfinally*/];\n                        case 13: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    }\n    else if (val === null || val === undefined) {\n        return NULL_VALUE;\n    }\n    return new StaticValue(val, getType(val));\n}\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getType(data) {\n    if (data === null || typeof data === 'undefined') {\n        return 'null';\n    }\n    if (Array.isArray(data)) {\n        return 'array';\n    }\n    if (data instanceof Path) {\n        return 'path';\n    }\n    if (data instanceof DateTime) {\n        return 'datetime';\n    }\n    return typeof data;\n}var TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction partialCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    if (aType !== bType) {\n        return null;\n    }\n    switch (aType) {\n        case 'number':\n        case 'boolean':\n            return a - b;\n        case 'string':\n            if (a < b)\n                return -1;\n            if (a > b)\n                return 1;\n            return 0;\n        case 'datetime':\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction totalCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    var aTypeOrder = TYPE_ORDER[aType] || 100;\n    var bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) {\n        return aTypeOrder - bTypeOrder;\n    }\n    var result = partialCompare(a, b);\n    if (result === null) {\n        result = 0;\n    }\n    return result;\n}var CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nvar MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    if (tokens.length === 0 || patterns.length === 0) {\n        return false;\n    }\n    return patterns.every(function (pattern) { return pattern(tokens); });\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, '').match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    var termsRe = matchPatternRegex(text);\n    return termsRe.map(function (re) { return function (tokens) { return tokens.some(function (token) { return re.test(token); }); }; });\n}\nfunction matchPatternRegex(text) {\n    var terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || [];\n    return terms.map(function (term) { return new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*'), \"$\"), 'i'); });\n}\nfunction gatherText(value, cb) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var success, part, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (value.type === 'string') {\n                        cb(value.data);\n                        return [2 /*return*/, true];\n                    }\n                    if (!value.isArray()) return [3 /*break*/, 13];\n                    success = true;\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 6, 7, 12]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 2;\n                case 2: return [4 /*yield*/, value_1.next()];\n                case 3:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 5];\n                    part = value_1_1.value;\n                    if (part.type === 'string') {\n                        cb(part.data);\n                    }\n                    else {\n                        success = false;\n                    }\n                    _b.label = 4;\n                case 4: return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 12];\n                case 6:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 12];\n                case 7:\n                    _b.trys.push([7, , 10, 11]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 9];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 8:\n                    _b.sent();\n                    _b.label = 9;\n                case 9: return [3 /*break*/, 11];\n                case 10:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 11: return [7 /*endfinally*/];\n                case 12: return [2 /*return*/, success];\n                case 13: return [2 /*return*/, false];\n            }\n        });\n    });\n}// BM25 similarity constants\nvar BM25k = 1.2;\nfunction evaluateScore(node, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var innerScore, boost, _a, leftScore, rightScore, leftScore, rightScore, res;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (node.type === 'OpCall' && node.op === 'match') {\n                        return [2 /*return*/, evaluateMatchScore(node.left, node.right, scope, execute)];\n                    }\n                    if (!(node.type === 'FuncCall' && node.name === 'boost')) return [3 /*break*/, 3];\n                    return [4 /*yield*/, evaluateScore(node.args[0], scope, execute)];\n                case 1:\n                    innerScore = _b.sent();\n                    return [4 /*yield*/, execute(node.args[1], scope)];\n                case 2:\n                    boost = _b.sent();\n                    if (boost.type === 'number' && innerScore > 0) {\n                        return [2 /*return*/, innerScore + boost.data];\n                    }\n                    return [2 /*return*/, 0];\n                case 3:\n                    _a = node.type;\n                    switch (_a) {\n                        case 'Or': return [3 /*break*/, 4];\n                        case 'And': return [3 /*break*/, 7];\n                    }\n                    return [3 /*break*/, 10];\n                case 4: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 5:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 6:\n                    rightScore = _b.sent();\n                    return [2 /*return*/, leftScore + rightScore];\n                case 7: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 8:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 9:\n                    rightScore = _b.sent();\n                    if (leftScore === 0 || rightScore === 0)\n                        return [2 /*return*/, 0];\n                    return [2 /*return*/, leftScore + rightScore];\n                case 10: return [4 /*yield*/, execute(node, scope)];\n                case 11:\n                    res = _b.sent();\n                    return [2 /*return*/, res.type === 'boolean' && res.data === true ? 1 : 0];\n            }\n        });\n    });\n}\nfunction evaluateMatchScore(left, right, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var text, pattern, tokens, terms, didSucceed, score, _loop_1, _i, terms_1, re;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(left, scope)];\n                case 1:\n                    text = _a.sent();\n                    return [4 /*yield*/, execute(right, scope)];\n                case 2:\n                    pattern = _a.sent();\n                    tokens = [];\n                    terms = [];\n                    return [4 /*yield*/, gatherText(text, function (part) {\n                            tokens = tokens.concat(matchTokenize(part));\n                        })];\n                case 3:\n                    _a.sent();\n                    return [4 /*yield*/, gatherText(pattern, function (part) {\n                            terms = terms.concat(matchPatternRegex(part));\n                        })];\n                case 4:\n                    didSucceed = _a.sent();\n                    if (!didSucceed) {\n                        return [2 /*return*/, 0];\n                    }\n                    if (tokens.length === 0 || terms.length === 0) {\n                        return [2 /*return*/, 0];\n                    }\n                    score = 0;\n                    _loop_1 = function (re) {\n                        var freq = tokens.reduce(function (c, token) { return c + (re.test(token) ? 1 : 0); }, 0);\n                        score += (freq * (BM25k + 1)) / (freq + BM25k);\n                    };\n                    for (_i = 0, terms_1 = terms; _i < terms_1.length; _i++) {\n                        re = terms_1[_i];\n                        _loop_1(re);\n                    }\n                    return [2 /*return*/, score];\n            }\n        });\n    });\n}function portableTextContent(value) {\n    return __awaiter(this, void 0, void 0, function () {\n        var texts;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(value.type === 'object')) return [3 /*break*/, 1];\n                    return [2 /*return*/, blockText(value.data)];\n                case 1:\n                    if (!value.isArray()) return [3 /*break*/, 3];\n                    return [4 /*yield*/, arrayText(value)];\n                case 2:\n                    texts = _a.sent();\n                    if (texts.length > 0) {\n                        return [2 /*return*/, texts.join('\\n\\n')];\n                    }\n                    _a.label = 3;\n                case 3: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction arrayText(value, result) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    if (result === void 0) { result = []; }\n    return __awaiter(this, void 0, void 0, function () {\n        var block, text, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 7, 8, 13]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 1;\n                case 1: return [4 /*yield*/, value_1.next()];\n                case 2:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 6];\n                    block = value_1_1.value;\n                    if (!(block.type === 'object')) return [3 /*break*/, 3];\n                    text = blockText(block.data);\n                    if (text !== null)\n                        result.push(text);\n                    return [3 /*break*/, 5];\n                case 3:\n                    if (!block.isArray()) return [3 /*break*/, 5];\n                    return [4 /*yield*/, arrayText(block, result)];\n                case 4:\n                    _b.sent();\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 1];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, result];\n            }\n        });\n    });\n}\nfunction blockText(obj) {\n    if (typeof obj._type !== 'string')\n        return null;\n    var children = obj.children;\n    if (!Array.isArray(children))\n        return null;\n    var result = '';\n    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n        var child = children_1[_i];\n        if (child &&\n            typeof child === 'object' &&\n            typeof child._type === 'string' &&\n            child._type === 'span' &&\n            typeof child.text === 'string') {\n            result += child.text;\n        }\n    }\n    return result;\n}function hasReference(value, pathSet) {\n    switch (getType(value)) {\n        case 'array':\n            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                var v = value_1[_i];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n        case 'object':\n            if (value._ref) {\n                return pathSet.has(value._ref);\n            }\n            for (var _a = 0, _b = Object.values(value); _a < _b.length; _a++) {\n                var v = _b[_a];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\nfunction countUTF8(str) {\n    var count = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        if (code >= 0xd800 && code <= 0xdbff) {\n            // High surrogate. Don't count this.\n            // By only counting the low surrogate we will correctly\n            // count the number of UTF-8 code points.\n            continue;\n        }\n        count++;\n    }\n    return count;\n}\nvar global = {};\nglobal.anywhere = function anywhere() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            throw new Error('not implemented');\n        });\n    });\n};\nglobal.anywhere.arity = 1;\nglobal.coalesce = function coalesce(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _i, args_1, arg, value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _i = 0, args_1 = args;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < args_1.length)) return [3 /*break*/, 4];\n                    arg = args_1[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    value = _a.sent();\n                    if (value.type !== 'null') {\n                        return [2 /*return*/, value];\n                    }\n                    _a.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.count = function count(args, scope, execute) {\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_1, inner_1_1, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (!inner.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_1 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_1.next()];\n                case 4:\n                    if (!(inner_1_1 = _b.sent(), !inner_1_1.done)) return [3 /*break*/, 6];\n                    inner_1_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_1_1 && !inner_1_1.done && (_a = inner_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n            }\n        });\n    });\n};\nglobal.count.arity = 1;\nglobal.dateTime = function dateTime(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var val;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    val = _a.sent();\n                    if (val.type === 'datetime') {\n                        return [2 /*return*/, val];\n                    }\n                    if (val.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, DateTime.parseToValue(val.data)];\n            }\n        });\n    });\n};\nglobal.dateTime.arity = 1;\nglobal.defined = function defined(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    return [2 /*return*/, inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE];\n            }\n        });\n    });\n};\nglobal.defined.arity = 1;\n// eslint-disable-next-line require-await\nglobal.identity = function identity(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.identity)];\n        });\n    });\n};\nglobal.identity.arity = 0;\nglobal.length = function length(args, scope, execute) {\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_2, inner_2_1, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (inner.type === 'string') {\n                        return [2 /*return*/, fromNumber(countUTF8(inner.data))];\n                    }\n                    if (!inner.isArray()) return [3 /*break*/, 14];\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_2 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_2.next()];\n                case 4:\n                    if (!(inner_2_1 = _b.sent(), !inner_2_1.done)) return [3 /*break*/, 6];\n                    inner_2_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_2_1 && !inner_2_1.done && (_a = inner_2[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_2)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_2) throw e_2.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n                case 14: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.length.arity = 1;\nglobal.path = function path(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    if (inner.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromPath(new Path(inner.data))];\n            }\n        });\n    });\n};\nglobal.path.arity = 1;\nglobal.string = function string(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    switch (value.type) {\n                        case 'number':\n                        case 'string':\n                        case 'boolean':\n                        case 'datetime':\n                            return [2 /*return*/, fromString(\"\".concat(value.data))];\n                        default:\n                            return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n};\nglobal.string.arity = 1;\nglobal.references = function references(args, scope, execute) {\n    var e_3, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var pathSet, _i, args_2, arg, path, path_1, path_1_1, elem, e_3_1, scopeValue;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    pathSet = new Set();\n                    _i = 0, args_2 = args;\n                    _b.label = 1;\n                case 1:\n                    if (!(_i < args_2.length)) return [3 /*break*/, 16];\n                    arg = args_2[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    path = _b.sent();\n                    if (!(path.type === 'string')) return [3 /*break*/, 3];\n                    pathSet.add(path.data);\n                    return [3 /*break*/, 15];\n                case 3:\n                    if (!path.isArray()) return [3 /*break*/, 15];\n                    _b.label = 4;\n                case 4:\n                    _b.trys.push([4, 9, 10, 15]);\n                    path_1 = (e_3 = void 0, __asyncValues(path));\n                    _b.label = 5;\n                case 5: return [4 /*yield*/, path_1.next()];\n                case 6:\n                    if (!(path_1_1 = _b.sent(), !path_1_1.done)) return [3 /*break*/, 8];\n                    elem = path_1_1.value;\n                    if (elem.type === 'string') {\n                        pathSet.add(elem.data);\n                    }\n                    _b.label = 7;\n                case 7: return [3 /*break*/, 5];\n                case 8: return [3 /*break*/, 15];\n                case 9:\n                    e_3_1 = _b.sent();\n                    e_3 = { error: e_3_1 };\n                    return [3 /*break*/, 15];\n                case 10:\n                    _b.trys.push([10, , 13, 14]);\n                    if (!(path_1_1 && !path_1_1.done && (_a = path_1[\"return\"]))) return [3 /*break*/, 12];\n                    return [4 /*yield*/, _a.call(path_1)];\n                case 11:\n                    _b.sent();\n                    _b.label = 12;\n                case 12: return [3 /*break*/, 14];\n                case 13:\n                    if (e_3) throw e_3.error;\n                    return [7 /*endfinally*/];\n                case 14: return [7 /*endfinally*/];\n                case 15:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 16:\n                    if (pathSet.size === 0) {\n                        return [2 /*return*/, FALSE_VALUE];\n                    }\n                    return [4 /*yield*/, scope.value.get()];\n                case 17:\n                    scopeValue = _b.sent();\n                    return [2 /*return*/, hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE];\n            }\n        });\n    });\n};\nglobal.references.arity = function (c) { return c >= 1; };\nglobal.round = function round(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, num, prec, precValue;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = value.data;\n                    prec = 0;\n                    if (!(args.length === 2)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    precValue = _a.sent();\n                    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    prec = precValue.data;\n                    _a.label = 3;\n                case 3:\n                    if (prec === 0) {\n                        if (num < 0) {\n                            // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n                            // The behavior we're interested in is to \"round half away from zero\".\n                            return [2 /*return*/, fromNumber(-Math.round(-num))];\n                        }\n                        return [2 /*return*/, fromNumber(Math.round(num))];\n                    }\n                    return [2 /*return*/, fromNumber(Number(num.toFixed(prec)))];\n            }\n        });\n    });\n};\nglobal.round.arity = function (count) { return count >= 1 && count <= 2; };\n// eslint-disable-next-line require-await\nglobal.now = function now(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.timestamp.toISOString())];\n        });\n    });\n};\nglobal.now.arity = 0;\n// eslint-disable-next-line require-await\nglobal.boost = function boost() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            // This should be handled by the scoring function.\n            throw new Error('unexpected boost call');\n        });\n    });\n};\nglobal.boost.arity = 2;\nvar string = {};\nstring.lower = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toLowerCase())];\n            }\n        });\n    });\n};\nstring.lower.arity = 1;\nstring.upper = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toUpperCase())];\n            }\n        });\n    });\n};\nstring.upper.arity = 1;\nglobal.lower = string.lower;\nglobal.upper = string.upper;\nvar pt = {};\npt.text = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, text;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    return [4 /*yield*/, portableTextContent(value)];\n                case 2:\n                    text = _a.sent();\n                    if (text === null) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(text)];\n            }\n        });\n    });\n};\npt.text.arity = 1;\nvar sanity = {};\n// eslint-disable-next-line require-await\nsanity.projectId = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.projectId)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\n// eslint-disable-next-line require-await\nsanity.dataset = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.dataset)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\nvar pipeFunctions = {};\npipeFunctions.order = function order(base, args, scope, execute) {\n    var base_1, base_1_1;\n    var e_4, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var mappers, directions, n, _i, args_3, mapper, direction, aux, idx, value, newScope, tuple, i, result, _b, _c, e_4_1;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0: \n                // eslint-disable-next-line max-len\n                // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                return [4 /*yield*/, true];\n                case 1:\n                    // eslint-disable-next-line max-len\n                    // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                    _d.sent();\n                    if (!base.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    mappers = [];\n                    directions = [];\n                    n = 0;\n                    for (_i = 0, args_3 = args; _i < args_3.length; _i++) {\n                        mapper = args_3[_i];\n                        direction = 'asc';\n                        if (mapper.type === 'Desc') {\n                            direction = 'desc';\n                            mapper = mapper.base;\n                        }\n                        else if (mapper.type === 'Asc') {\n                            mapper = mapper.base;\n                        }\n                        mappers.push(mapper);\n                        directions.push(direction);\n                        n++;\n                    }\n                    aux = [];\n                    idx = 0;\n                    _d.label = 2;\n                case 2:\n                    _d.trys.push([2, 13, 14, 19]);\n                    base_1 = __asyncValues(base);\n                    _d.label = 3;\n                case 3: return [4 /*yield*/, base_1.next()];\n                case 4:\n                    if (!(base_1_1 = _d.sent(), !base_1_1.done)) return [3 /*break*/, 12];\n                    value = base_1_1.value;\n                    newScope = scope.createNested(value);\n                    return [4 /*yield*/, value.get()];\n                case 5:\n                    tuple = [_d.sent(), idx];\n                    i = 0;\n                    _d.label = 6;\n                case 6:\n                    if (!(i < n)) return [3 /*break*/, 10];\n                    return [4 /*yield*/, execute(mappers[i], newScope)];\n                case 7:\n                    result = _d.sent();\n                    _c = (_b = tuple).push;\n                    return [4 /*yield*/, result.get()];\n                case 8:\n                    _c.apply(_b, [_d.sent()]);\n                    _d.label = 9;\n                case 9:\n                    i++;\n                    return [3 /*break*/, 6];\n                case 10:\n                    aux.push(tuple);\n                    idx++;\n                    _d.label = 11;\n                case 11: return [3 /*break*/, 3];\n                case 12: return [3 /*break*/, 19];\n                case 13:\n                    e_4_1 = _d.sent();\n                    e_4 = { error: e_4_1 };\n                    return [3 /*break*/, 19];\n                case 14:\n                    _d.trys.push([14, , 17, 18]);\n                    if (!(base_1_1 && !base_1_1.done && (_a = base_1[\"return\"]))) return [3 /*break*/, 16];\n                    return [4 /*yield*/, _a.call(base_1)];\n                case 15:\n                    _d.sent();\n                    _d.label = 16;\n                case 16: return [3 /*break*/, 18];\n                case 17:\n                    if (e_4) throw e_4.error;\n                    return [7 /*endfinally*/];\n                case 18: return [7 /*endfinally*/];\n                case 19:\n                    aux.sort(function (aTuple, bTuple) {\n                        for (var i = 0; i < n; i++) {\n                            var c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n                            if (directions[i] === 'desc') {\n                                c = -c;\n                            }\n                            if (c !== 0) {\n                                return c;\n                            }\n                        }\n                        // Fallback to sorting on the original index for stable sorting.\n                        return aTuple[1] - bTuple[1];\n                    });\n                    return [2 /*return*/, fromJS(aux.map(function (v) { return v[0]; }))];\n            }\n        });\n    });\n};\npipeFunctions.order.arity = function (count) { return count >= 1; };\n// eslint-disable-next-line require-await\npipeFunctions.score = function score(base, args, scope, execute) {\n    var base_2, base_2_1;\n    var e_5, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var unknown, scored, value, _b, _c, newScope, valueScore, _i, args_4, arg, _d, newObject, e_5_1;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (!base.isArray())\n                        return [2 /*return*/, NULL_VALUE\n                            // Anything that isn't an object should be sorted first.\n                        ];\n                    unknown = [];\n                    scored = [];\n                    _e.label = 1;\n                case 1:\n                    _e.trys.push([1, 12, 13, 18]);\n                    base_2 = __asyncValues(base);\n                    _e.label = 2;\n                case 2: return [4 /*yield*/, base_2.next()];\n                case 3:\n                    if (!(base_2_1 = _e.sent(), !base_2_1.done)) return [3 /*break*/, 11];\n                    value = base_2_1.value;\n                    if (!(value.type !== 'object')) return [3 /*break*/, 5];\n                    _c = (_b = unknown).push;\n                    return [4 /*yield*/, value.get()];\n                case 4:\n                    _c.apply(_b, [_e.sent()]);\n                    return [3 /*break*/, 10];\n                case 5:\n                    newScope = scope.createNested(value);\n                    valueScore = typeof value.data._score === 'number' ? value.data._score : 0;\n                    _i = 0, args_4 = args;\n                    _e.label = 6;\n                case 6:\n                    if (!(_i < args_4.length)) return [3 /*break*/, 9];\n                    arg = args_4[_i];\n                    _d = valueScore;\n                    return [4 /*yield*/, evaluateScore(arg, newScope, execute)];\n                case 7:\n                    valueScore = _d + _e.sent();\n                    _e.label = 8;\n                case 8:\n                    _i++;\n                    return [3 /*break*/, 6];\n                case 9:\n                    newObject = Object.assign({}, value.data, { _score: valueScore });\n                    scored.push(newObject);\n                    _e.label = 10;\n                case 10: return [3 /*break*/, 2];\n                case 11: return [3 /*break*/, 18];\n                case 12:\n                    e_5_1 = _e.sent();\n                    e_5 = { error: e_5_1 };\n                    return [3 /*break*/, 18];\n                case 13:\n                    _e.trys.push([13, , 16, 17]);\n                    if (!(base_2_1 && !base_2_1.done && (_a = base_2[\"return\"]))) return [3 /*break*/, 15];\n                    return [4 /*yield*/, _a.call(base_2)];\n                case 14:\n                    _e.sent();\n                    _e.label = 15;\n                case 15: return [3 /*break*/, 17];\n                case 16:\n                    if (e_5) throw e_5.error;\n                    return [7 /*endfinally*/];\n                case 17: return [7 /*endfinally*/];\n                case 18:\n                    scored.sort(function (a, b) { return b._score - a._score; });\n                    return [2 /*return*/, fromJS(scored)];\n            }\n        });\n    });\n};\npipeFunctions.score.arity = function (count) { return count >= 1; };\nvar delta = {};\ndelta.operation = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        var hasBefore, hasAfter;\n        return __generator(this, function (_a) {\n            hasBefore = scope.context.before !== null;\n            hasAfter = scope.context.after !== null;\n            if (hasBefore && hasAfter) {\n                return [2 /*return*/, fromString('update')];\n            }\n            if (hasAfter) {\n                return [2 /*return*/, fromString('create')];\n            }\n            if (hasBefore) {\n                return [2 /*return*/, fromString('delete')];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\ndelta.changedAny = function () {\n    throw new Error('not implemented');\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = 'delta';\ndelta.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = 'delta';\nvar diff = {};\ndiff.changedAny = function () {\n    throw new Error('not implemented');\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndiff.changedOnly.arity = 3;\nvar namespaces = {\n    global: global,\n    string: string,\n    pt: pt,\n    delta: delta,\n    diff: diff,\n    sanity: sanity\n};const WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\n\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position);\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks);\n          pos = skipWS(str, pos + 1);\n          while (true) {\n            rhs = parseExpr(str, pos, 0);\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position);\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++;\n          marks.push({name: 'tuple_end', position: pos});\n          break\n        }\n        case ')': {\n          pos++;\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks);\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}];\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos});\n            pos = skipWS(str, pos + 3);\n          }\n\n          let res = parseExpr(str, pos, 0);\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++;\n        marks.push({name: 'array_end', position: pos});\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '^': {\n      pos++;\n      marks = [];\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos});\n        pos += 2;\n      }\n      marks.push({name: 'parent', position: startPos});\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}];\n      pos++;\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}];\n      pos++;\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      if (identLen) {\n        pos += 1 + identLen;\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ];\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = 'integer';\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          if (fracLen) {\n            name = 'float';\n            pos += 1 + fracLen;\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci';\n          pos++;\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++;\n          }\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen;\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ];\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        pos += identLen;\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === 'error') return result\n            marks = result.marks;\n            pos = result.position;\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ];\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12;\n  let trav;\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break\n    }\n\n    trav = parseTraversal(str, innerPos);\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos});\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks);\n        pos = trav.position;\n        trav = parseTraversal(str, skipWS(str, pos));\n      }\n      marks.push({name: 'traversal_end', position: pos});\n      continue\n    }\n\n    let token = str[innerPos];\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1];\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks);\n            marks.unshift({name: 'pair', position: startPos});\n            pos = rhs.position;\n            lhsLevel = PREC_PAIR;\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = PREC_COMP;\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'add', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_ADD;\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'sub', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_SUB;\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'pow', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_POW;\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mul', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MUL;\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'div', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_DIV;\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mod', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MOD;\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1;\n        if (str[nextPos] === '=') {\n          nextPos++;\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'or', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_OR;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1);\n          let identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen;\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks);\n            marks.unshift({name: 'pipecall', position: startPos});\n            pos = result.position;\n            lhsLevel = 11;\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'and', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_AND;\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos});\n        pos = innerPos + 4;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos});\n        pos = innerPos + 3;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT);\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2);\n\n            let isGroup = false;\n\n            if (str[pos] === '(') {\n              isGroup = true;\n              pos = skipWS(str, pos + 1);\n            }\n\n            let rangePos = pos;\n            let result = parseExpr(str, pos, PREC_COMP + 1);\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position);\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range';\n              if (str[pos + 2] === '.') {\n                type = 'exc_range';\n                pos = skipWS(str, pos + 3);\n              } else {\n                pos = skipWS(str, pos + 2);\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1);\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos});\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks);\n              pos = rhs.position;\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos});\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n              marks = marks.concat(result.marks);\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos);\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++;\n            }\n\n            lhsLevel = PREC_COMP;\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = 4;\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position;\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos;\n      let identLen = parseRegex(str, pos, IDENT);\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen;\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}];\n      pos += 2;\n\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        );\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos;\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position);\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range';\n        if (str[pos + 2] === '.') {\n          type = 'exc_range';\n          pos += 3;\n        } else {\n          pos += 2;\n        }\n\n        pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position);\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos);\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos});\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos});\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n\n  marks.push({name: 'func_call', position: startPos});\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos});\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen});\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++;\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 1);\n  }\n\n  let lastPos = pos;\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1);\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos});\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}];\n  pos = skipWS(str, pos + 1);\n\n  while (str[pos] !== '}') {\n    let pairPos = pos;\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3);\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos});\n        marks = marks.concat(expr.marks);\n        pos = expr.position;\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos});\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos});\n        marks = marks.concat(expr.marks, value.marks);\n        pos = value.position;\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks);\n        pos = expr.position;\n      }\n    }\n    pos = skipWS(str, pos);\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1);\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++;\n  marks.push({name: 'object_end', position: pos});\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{name: 'str', position: pos}];\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos});\n        pos++;\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos});\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3});\n            pos = str.indexOf('}', pos + 3);\n            marks.push({name: 'unicode_hex_end', position: pos});\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2});\n            marks.push({name: 'unicode_hex_end', position: pos + 6});\n            pos += 5;\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1});\n          pos += 1;\n        }\n        marks.push({name: 'str_start', position: pos + 1});\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null\n}/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a, b) {\n    return function (base) { return b(a(base)); };\n}\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner) {\n    return function (base) { return ({ type: 'Map', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction flatMap(inner) {\n    return function (base) { return ({ type: 'FlatMap', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction traverseArray(build, right) {\n    if (!right) {\n        return {\n            type: 'a-a',\n            build: build\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(build, right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(build, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'a-a',\n                build: join(build, map(right.build))\n            };\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) {\n        return {\n            type: 'a-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'a-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(map(mapper), right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(map(mapper), right.build)\n            };\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}var isEqual = equality;\nfunction equality(a, b) {\n    if ((a.type === 'string' && b.type === 'string') ||\n        (a.type === 'boolean' && b.type === 'boolean') ||\n        (a.type === 'null' && b.type === 'null') ||\n        (a.type === 'number' && b.type === 'number')) {\n        return a.data === b.data;\n    }\n    if (a.type === 'datetime' && b.type === 'datetime') {\n        return a.data.equals(b.data);\n    }\n    return false;\n}var operators = {\n    '==': function eq(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '!=': function neq(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    '>': function gt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '>=': function gte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<': function lt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<=': function lte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    \"in\": function inop(left, right) {\n        var right_1, right_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var b, e_1_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (right.type === 'path') {\n                            if (left.type !== 'string') {\n                                return [2 /*return*/, NULL_VALUE];\n                            }\n                            return [2 /*return*/, right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        if (!right.isArray()) return [3 /*break*/, 13];\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 6, 7, 12]);\n                        right_1 = __asyncValues(right);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, right_1.next()];\n                    case 3:\n                        if (!(right_1_1 = _b.sent(), !right_1_1.done)) return [3 /*break*/, 5];\n                        b = right_1_1.value;\n                        if (isEqual(left, b)) {\n                            return [2 /*return*/, TRUE_VALUE];\n                        }\n                        _b.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _b.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _b.trys.push([7, , 10, 11]);\n                        if (!(right_1_1 && !right_1_1.done && (_a = right_1[\"return\"]))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(right_1)];\n                    case 8:\n                        _b.sent();\n                        _b.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12: return [2 /*return*/, FALSE_VALUE];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    match: function match(left, right) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokens, patterns, didSucceed, matched;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tokens = [];\n                        patterns = [];\n                        return [4 /*yield*/, gatherText(left, function (part) {\n                                tokens = tokens.concat(matchTokenize(part));\n                            })];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, gatherText(right, function (part) {\n                                patterns = patterns.concat(matchAnalyzePattern(part));\n                            })];\n                    case 2:\n                        didSucceed = _a.sent();\n                        if (!didSucceed) {\n                            return [2 /*return*/, FALSE_VALUE];\n                        }\n                        matched = matchText(tokens, patterns);\n                        return [2 /*return*/, matched ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    '+': function plus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data + right.data);\n        }\n        if (left.type === 'string' && right.type === 'string') {\n            return fromString(left.data + right.data);\n        }\n        if (left.type === 'object' && right.type === 'object') {\n            return fromJS(__assign(__assign({}, left.data), right.data));\n        }\n        if (left.type === 'array' && right.type === 'array') {\n            return fromJS(left.data.concat(right.data));\n        }\n        if (left.isArray() && right.isArray()) {\n            return new StreamValue(function () {\n                return __asyncGenerator(this, arguments, function () {\n                    var left_1, left_1_1, val, e_2_1, right_2, right_2_1, val, e_3_1;\n                    var e_2, _a, e_3, _b;\n                    return __generator(this, function (_c) {\n                        switch (_c.label) {\n                            case 0:\n                                _c.trys.push([0, 7, 8, 13]);\n                                left_1 = __asyncValues(left);\n                                _c.label = 1;\n                            case 1: return [4 /*yield*/, __await(left_1.next())];\n                            case 2:\n                                if (!(left_1_1 = _c.sent(), !left_1_1.done)) return [3 /*break*/, 6];\n                                val = left_1_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 3: return [4 /*yield*/, _c.sent()];\n                            case 4:\n                                _c.sent();\n                                _c.label = 5;\n                            case 5: return [3 /*break*/, 1];\n                            case 6: return [3 /*break*/, 13];\n                            case 7:\n                                e_2_1 = _c.sent();\n                                e_2 = { error: e_2_1 };\n                                return [3 /*break*/, 13];\n                            case 8:\n                                _c.trys.push([8, , 11, 12]);\n                                if (!(left_1_1 && !left_1_1.done && (_a = left_1[\"return\"]))) return [3 /*break*/, 10];\n                                return [4 /*yield*/, __await(_a.call(left_1))];\n                            case 9:\n                                _c.sent();\n                                _c.label = 10;\n                            case 10: return [3 /*break*/, 12];\n                            case 11:\n                                if (e_2) throw e_2.error;\n                                return [7 /*endfinally*/];\n                            case 12: return [7 /*endfinally*/];\n                            case 13:\n                                _c.trys.push([13, 20, 21, 26]);\n                                right_2 = __asyncValues(right);\n                                _c.label = 14;\n                            case 14: return [4 /*yield*/, __await(right_2.next())];\n                            case 15:\n                                if (!(right_2_1 = _c.sent(), !right_2_1.done)) return [3 /*break*/, 19];\n                                val = right_2_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 16: return [4 /*yield*/, _c.sent()];\n                            case 17:\n                                _c.sent();\n                                _c.label = 18;\n                            case 18: return [3 /*break*/, 14];\n                            case 19: return [3 /*break*/, 26];\n                            case 20:\n                                e_3_1 = _c.sent();\n                                e_3 = { error: e_3_1 };\n                                return [3 /*break*/, 26];\n                            case 21:\n                                _c.trys.push([21, , 24, 25]);\n                                if (!(right_2_1 && !right_2_1.done && (_b = right_2[\"return\"]))) return [3 /*break*/, 23];\n                                return [4 /*yield*/, __await(_b.call(right_2))];\n                            case 22:\n                                _c.sent();\n                                _c.label = 23;\n                            case 23: return [3 /*break*/, 25];\n                            case 24:\n                                if (e_3) throw e_3.error;\n                                return [7 /*endfinally*/];\n                            case 25: return [7 /*endfinally*/];\n                            case 26: return [2 /*return*/];\n                        }\n                    });\n                });\n            });\n        }\n        return NULL_VALUE;\n    },\n    '-': function minus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(-right.data));\n        }\n        if (left.type === 'datetime' && right.type === 'datetime') {\n            return fromNumber(left.data.difference(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data - right.data);\n        }\n        return NULL_VALUE;\n    },\n    '*': numericOperator(function (a, b) { return a * b; }),\n    '/': numericOperator(function (a, b) { return a / b; }),\n    '%': numericOperator(function (a, b) { return a % b; }),\n    '**': numericOperator(function (a, b) { return Math.pow(a, b); })\n};\nfunction numericOperator(impl) {\n    return function (left, right) {\n        if (left.type === 'number' && right.type === 'number') {\n            var result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}var Scope = /** @class */ (function () {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    function Scope(params, source, value, context, parent) {\n        this.isHidden = false;\n        this.params = params;\n        this.source = source;\n        this.value = value;\n        this.context = context;\n        this.parent = parent;\n    }\n    Scope.prototype.createNested = function (value) {\n        if (this.isHidden) {\n            return new Scope(this.params, this.source, value, this.context, this.parent);\n        }\n        return new Scope(this.params, this.source, value, this.context, this);\n    };\n    Scope.prototype.createHidden = function (value) {\n        var result = this.createNested(value);\n        result.isHidden = true;\n        return result;\n    };\n    return Scope;\n}());function evaluate(node, scope, execute) {\n    if (execute === void 0) { execute = evaluate; }\n    var func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(value, cb) {\n    if ('then' in value) {\n        return value.then(cb);\n    }\n    return cb(value);\n}\nvar EXECUTORS = {\n    This: function (_, scope) {\n        return scope.value;\n    },\n    Selector: function () {\n        // These should be evaluated separely using a different evaluator.\n        // At the mooment we haven't implemented this.\n        throw new Error('Selectors can not be evaluated');\n    },\n    Everything: function (_, scope) {\n        return scope.source;\n    },\n    Parameter: function (_a, scope) {\n        var name = _a.name;\n        return fromJS(scope.params[name]);\n    },\n    Context: function (_a, scope) {\n        var key = _a.key;\n        if (key === 'before' || key === 'after') {\n            var value = scope.context[key];\n            return value || NULL_VALUE;\n        }\n        throw new Error(\"unknown context key: \".concat(key));\n    },\n    Parent: function (_a, scope) {\n        var n = _a.n;\n        var current = scope;\n        for (var i = 0; i < n; i++) {\n            if (!current.parent) {\n                return NULL_VALUE;\n            }\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall: function (_a, scope, execute) {\n        var _this = this;\n        var op = _a.op, left = _a.left, right = _a.right;\n        var func = operators[op];\n        if (!func) {\n            throw new Error(\"Unknown operator: \".concat(op));\n        }\n        var leftValue = execute(left, scope);\n        var rightValue = execute(right, scope);\n        // Avoid uneccesary promises\n        // This is required for constant evaluation to work correctly.\n        if ('then' in leftValue || 'then' in rightValue) {\n            return (function () { return __awaiter(_this, void 0, void 0, function () { var _a, _b; return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = func;\n                        return [4 /*yield*/, leftValue];\n                    case 1:\n                        _b = [_c.sent()];\n                        return [4 /*yield*/, rightValue];\n                    case 2: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()]))];\n                }\n            }); }); })();\n        }\n        return func(leftValue, rightValue);\n    },\n    Select: function (_a, scope, execute) {\n        var alternatives = _a.alternatives, fallback = _a.fallback;\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, alternatives_1, alt, altCond;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _i = 0, alternatives_1 = alternatives;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < alternatives_1.length)) return [3 /*break*/, 4];\n                        alt = alternatives_1[_i];\n                        return [4 /*yield*/, execute(alt.condition, scope)];\n                    case 2:\n                        altCond = _b.sent();\n                        if (altCond.type === 'boolean' && altCond.data === true) {\n                            return [2 /*return*/, execute(alt.value, scope)];\n                        }\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (fallback) {\n                            return [2 /*return*/, execute(fallback, scope)];\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    InRange: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, leftValue, rightValue, leftCmp, _b, _c, rightCmp, _d, _e;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _f.sent();\n                        return [4 /*yield*/, execute(left, scope)];\n                    case 2:\n                        leftValue = _f.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 3:\n                        rightValue = _f.sent();\n                        _b = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c = [_f.sent()];\n                        return [4 /*yield*/, leftValue.get()];\n                    case 5:\n                        leftCmp = _b.apply(void 0, _c.concat([_f.sent()]));\n                        if (leftCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _d = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 6:\n                        _e = [_f.sent()];\n                        return [4 /*yield*/, rightValue.get()];\n                    case 7:\n                        rightCmp = _d.apply(void 0, _e.concat([_f.sent()]));\n                        if (rightCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (isInclusive) {\n                            return [2 /*return*/, leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        return [2 /*return*/, leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    Filter: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var baseValue_1, baseValue_1_1, elem, newScope, exprValue, e_1_1;\n                                    var e_1, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                baseValue_1 = __asyncValues(baseValue);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(baseValue_1.next())];\n                                            case 2:\n                                                if (!(baseValue_1_1 = _b.sent(), !baseValue_1_1.done)) return [3 /*break*/, 7];\n                                                elem = baseValue_1_1.value;\n                                                newScope = scope.createNested(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                exprValue = _b.sent();\n                                                if (!(exprValue.type === 'boolean' && exprValue.data === true)) return [3 /*break*/, 6];\n                                                return [4 /*yield*/, __await(elem)];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_1_1 = _b.sent();\n                                                e_1 = { error: e_1_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(baseValue_1_1 && !baseValue_1_1.done && (_a = baseValue_1[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(baseValue_1))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_1) throw e_1.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    Projection: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, newScope;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (baseValue.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        newScope = scope.createNested(baseValue);\n                        return [2 /*return*/, execute(expr, newScope)];\n                }\n            });\n        });\n    },\n    FuncCall: function (_a, scope, execute) {\n        var func = _a.func, args = _a.args;\n        return func(args, scope, execute);\n    },\n    PipeFuncCall: function (_a, scope, execute) {\n        var func = _a.func, base = _a.base, args = _a.args;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        return [2 /*return*/, func(baseValue, args, scope, execute)];\n                }\n            });\n        });\n    },\n    AccessAttribute: function (_a, scope, execute) {\n        var base = _a.base, name = _a.name;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        value = scope.value;\n                        if (!base) return [3 /*break*/, 2];\n                        return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        if (value.type === 'object') {\n                            if (value.data.hasOwnProperty(name)) {\n                                return [2 /*return*/, fromJS(value.data[name])];\n                            }\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    AccessElement: function (_a, scope, execute) {\n        var base = _a.base, index = _a.index;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, data, finalIndex;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        data = _b.sent();\n                        finalIndex = index < 0 ? index + data.length : index;\n                        return [2 /*return*/, fromJS(data[finalIndex])];\n                }\n            });\n        });\n    },\n    Slice: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, array, leftIdx, rightIdx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        array = (_b.sent());\n                        leftIdx = left;\n                        rightIdx = right;\n                        // Handle negative index\n                        if (leftIdx < 0) {\n                            leftIdx = array.length + leftIdx;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = array.length + rightIdx;\n                        }\n                        // Convert from inclusive to exclusive index\n                        if (isInclusive) {\n                            rightIdx++;\n                        }\n                        if (leftIdx < 0) {\n                            leftIdx = 0;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = 0;\n                        }\n                        // Note: At this point the indices might point out-of-bound, but\n                        // .slice handles this correctly.\n                        return [2 /*return*/, fromJS(array.slice(leftIdx, rightIdx))];\n                }\n            });\n        });\n    },\n    Deref: function (_a, scope, execute) {\n        var e_2, _b;\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, id, _c, _d, doc, e_2_1;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _e.sent();\n                        if (!scope.source.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (value.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        id = value.data._ref;\n                        if (typeof id !== 'string') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _e.label = 2;\n                    case 2:\n                        _e.trys.push([2, 7, 8, 13]);\n                        _c = __asyncValues(scope.source);\n                        _e.label = 3;\n                    case 3: return [4 /*yield*/, _c.next()];\n                    case 4:\n                        if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 6];\n                        doc = _d.value;\n                        if (doc.type === 'object' && id === doc.data._id) {\n                            return [2 /*return*/, doc];\n                        }\n                        _e.label = 5;\n                    case 5: return [3 /*break*/, 3];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_2_1 = _e.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _e.trys.push([8, , 11, 12]);\n                        if (!(_d && !_d.done && (_b = _c[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _b.call(_c)];\n                    case 9:\n                        _e.sent();\n                        _e.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    Value: function (_a) {\n        var value = _a.value;\n        return fromJS(value);\n    },\n    Group: function (_a, scope, execute) {\n        var base = _a.base;\n        return execute(base, scope);\n    },\n    Object: function (_a, scope, execute) {\n        var attributes = _a.attributes;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _i, attributes_1, attr, attrType, _b, value, _c, _d, cond, value, value;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        result = {};\n                        _i = 0, attributes_1 = attributes;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < attributes_1.length)) return [3 /*break*/, 12];\n                        attr = attributes_1[_i];\n                        attrType = attr.type;\n                        _b = attr.type;\n                        switch (_b) {\n                            case 'ObjectAttributeValue': return [3 /*break*/, 2];\n                            case 'ObjectConditionalSplat': return [3 /*break*/, 5];\n                            case 'ObjectSplat': return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 10];\n                    case 2: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 3:\n                        value = _e.sent();\n                        _c = result;\n                        _d = attr.name;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c[_d] = _e.sent();\n                        return [3 /*break*/, 11];\n                    case 5: return [4 /*yield*/, execute(attr.condition, scope)];\n                    case 6:\n                        cond = _e.sent();\n                        if (cond.type !== 'boolean' || cond.data === false) {\n                            return [3 /*break*/, 11];\n                        }\n                        return [4 /*yield*/, execute(attr.value, scope)];\n                    case 7:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 8: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 9:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 10: throw new Error(\"Unknown node type: \".concat(attrType));\n                    case 11:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 12: return [2 /*return*/, fromJS(result)];\n                }\n            });\n        });\n    },\n    Array: function (_a, scope, execute) {\n        var elements = _a.elements;\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var _i, elements_1, element, value, value_1, value_1_1, v, e_3_1;\n                var e_3, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _i = 0, elements_1 = elements;\n                            _b.label = 1;\n                        case 1:\n                            if (!(_i < elements_1.length)) return [3 /*break*/, 21];\n                            element = elements_1[_i];\n                            return [4 /*yield*/, __await(execute(element.value, scope))];\n                        case 2:\n                            value = _b.sent();\n                            if (!element.isSplat) return [3 /*break*/, 17];\n                            if (!value.isArray()) return [3 /*break*/, 16];\n                            _b.label = 3;\n                        case 3:\n                            _b.trys.push([3, 10, 11, 16]);\n                            value_1 = (e_3 = void 0, __asyncValues(value));\n                            _b.label = 4;\n                        case 4: return [4 /*yield*/, __await(value_1.next())];\n                        case 5:\n                            if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 9];\n                            v = value_1_1.value;\n                            return [4 /*yield*/, __await(v)];\n                        case 6: return [4 /*yield*/, _b.sent()];\n                        case 7:\n                            _b.sent();\n                            _b.label = 8;\n                        case 8: return [3 /*break*/, 4];\n                        case 9: return [3 /*break*/, 16];\n                        case 10:\n                            e_3_1 = _b.sent();\n                            e_3 = { error: e_3_1 };\n                            return [3 /*break*/, 16];\n                        case 11:\n                            _b.trys.push([11, , 14, 15]);\n                            if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 13];\n                            return [4 /*yield*/, __await(_a.call(value_1))];\n                        case 12:\n                            _b.sent();\n                            _b.label = 13;\n                        case 13: return [3 /*break*/, 15];\n                        case 14:\n                            if (e_3) throw e_3.error;\n                            return [7 /*endfinally*/];\n                        case 15: return [7 /*endfinally*/];\n                        case 16: return [3 /*break*/, 20];\n                        case 17: return [4 /*yield*/, __await(value)];\n                        case 18: return [4 /*yield*/, _b.sent()];\n                        case 19:\n                            _b.sent();\n                            _b.label = 20;\n                        case 20:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 21: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    },\n    Tuple: function () {\n        throw new Error('tuples can not be evaluated');\n    },\n    Or: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, FALSE_VALUE];\n                }\n            });\n        });\n    },\n    And: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Not: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (value.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, value.data ? FALSE_VALUE : TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Neg: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(-value.data);\n        });\n    },\n    Pos: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(value.data);\n        });\n    },\n    Asc: function () {\n        return NULL_VALUE;\n    },\n    Desc: function () {\n        return NULL_VALUE;\n    },\n    ArrayCoerce: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        return [2 /*return*/, value.isArray() ? value : NULL_VALUE];\n                }\n            });\n        });\n    },\n    Map: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_2, value_2_1, elem, newScope, e_4_1;\n                                    var e_4, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                value_2 = __asyncValues(value);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_2.next())];\n                                            case 2:\n                                                if (!(value_2_1 = _b.sent(), !value_2_1.done)) return [3 /*break*/, 7];\n                                                elem = value_2_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3: return [4 /*yield*/, __await.apply(void 0, [_b.sent()])];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_4_1 = _b.sent();\n                                                e_4 = { error: e_4_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(value_2_1 && !value_2_1.done && (_a = value_2[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(value_2))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_4) throw e_4.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    FlatMap: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_3, value_3_1, elem, newScope, innerValue, innerValue_1, innerValue_1_1, inner, e_5_1, e_6_1;\n                                    var e_6, _a, e_5, _b;\n                                    return __generator(this, function (_c) {\n                                        switch (_c.label) {\n                                            case 0:\n                                                _c.trys.push([0, 23, 24, 29]);\n                                                value_3 = __asyncValues(value);\n                                                _c.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_3.next())];\n                                            case 2:\n                                                if (!(value_3_1 = _c.sent(), !value_3_1.done)) return [3 /*break*/, 22];\n                                                elem = value_3_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                innerValue = _c.sent();\n                                                if (!innerValue.isArray()) return [3 /*break*/, 18];\n                                                _c.label = 4;\n                                            case 4:\n                                                _c.trys.push([4, 11, 12, 17]);\n                                                innerValue_1 = (e_5 = void 0, __asyncValues(innerValue));\n                                                _c.label = 5;\n                                            case 5: return [4 /*yield*/, __await(innerValue_1.next())];\n                                            case 6:\n                                                if (!(innerValue_1_1 = _c.sent(), !innerValue_1_1.done)) return [3 /*break*/, 10];\n                                                inner = innerValue_1_1.value;\n                                                return [4 /*yield*/, __await(inner)];\n                                            case 7: return [4 /*yield*/, _c.sent()];\n                                            case 8:\n                                                _c.sent();\n                                                _c.label = 9;\n                                            case 9: return [3 /*break*/, 5];\n                                            case 10: return [3 /*break*/, 17];\n                                            case 11:\n                                                e_5_1 = _c.sent();\n                                                e_5 = { error: e_5_1 };\n                                                return [3 /*break*/, 17];\n                                            case 12:\n                                                _c.trys.push([12, , 15, 16]);\n                                                if (!(innerValue_1_1 && !innerValue_1_1.done && (_b = innerValue_1[\"return\"]))) return [3 /*break*/, 14];\n                                                return [4 /*yield*/, __await(_b.call(innerValue_1))];\n                                            case 13:\n                                                _c.sent();\n                                                _c.label = 14;\n                                            case 14: return [3 /*break*/, 16];\n                                            case 15:\n                                                if (e_5) throw e_5.error;\n                                                return [7 /*endfinally*/];\n                                            case 16: return [7 /*endfinally*/];\n                                            case 17: return [3 /*break*/, 21];\n                                            case 18: return [4 /*yield*/, __await(innerValue)];\n                                            case 19: return [4 /*yield*/, _c.sent()];\n                                            case 20:\n                                                _c.sent();\n                                                _c.label = 21;\n                                            case 21: return [3 /*break*/, 1];\n                                            case 22: return [3 /*break*/, 29];\n                                            case 23:\n                                                e_6_1 = _c.sent();\n                                                e_6 = { error: e_6_1 };\n                                                return [3 /*break*/, 29];\n                                            case 24:\n                                                _c.trys.push([24, , 27, 28]);\n                                                if (!(value_3_1 && !value_3_1.done && (_a = value_3[\"return\"]))) return [3 /*break*/, 26];\n                                                return [4 /*yield*/, __await(_a.call(value_3))];\n                                            case 25:\n                                                _c.sent();\n                                                _c.label = 26;\n                                            case 26: return [3 /*break*/, 28];\n                                            case 27:\n                                                if (e_6) throw e_6.error;\n                                                return [7 /*endfinally*/];\n                                            case 28: return [7 /*endfinally*/];\n                                            case 29: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    }\n};\n/**\n * Evaluates a query.\n */\nfunction evaluateQuery(tree, options) {\n    if (options === void 0) { options = {}; }\n    var root = fromJS(options.root);\n    var dataset = fromJS(options.dataset);\n    var params = __assign({}, options.params);\n    var scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || new Date(),\n        identity: options.identity === undefined ? 'me' : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null\n    }, null);\n    return evaluate(tree, scope);\n}function canConstantEvaluate(node) {\n    switch (node.type) {\n        case 'Group':\n        case 'Value':\n        case 'Parameter':\n            return true;\n        case 'Pos':\n        case 'Neg':\n            return canConstantEvaluate(node.base);\n        case 'OpCall':\n            switch (node.op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                case '**':\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nvar DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: 'me', before: null, after: null }, null);\nfunction tryConstantEvaluate(node) {\n    if (!canConstantEvaluate(node)) {\n        return null;\n    }\n    return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n    var value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if ('then' in value) {\n        throw new Error('BUG: constant evaluate should never return a promise');\n    }\n    return value;\n}var ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '\\\\': '\\\\',\n    '/': '/',\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n};\nfunction expandHex(str) {\n    var charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nvar GroqQueryError = /** @class */ (function (_super) {\n    __extends(GroqQueryError, _super);\n    function GroqQueryError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = 'GroqQueryError';\n        return _this;\n    }\n    return GroqQueryError;\n}(Error));\nvar EXPR_BUILDER = {\n    group: function (p) {\n        var inner = p.process(EXPR_BUILDER);\n        return {\n            type: 'Group',\n            base: inner\n        };\n    },\n    everything: function () {\n        return { type: 'Everything' };\n    },\n    \"this\": function () {\n        return { type: 'This' };\n    },\n    parent: function () {\n        return {\n            type: 'Parent',\n            n: 1\n        };\n    },\n    dblparent: function (p) {\n        var next = p.process(EXPR_BUILDER);\n        return {\n            type: 'Parent',\n            n: next.n + 1\n        };\n    },\n    traverse: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var traversalList = [];\n        while (p.getMark().name !== 'traversal_end') {\n            traversalList.push(p.process(TRAVERSE_BUILDER));\n        }\n        p.shift();\n        var traversal = null;\n        for (var i = traversalList.length - 1; i >= 0; i--) {\n            traversal = traversalList[i](traversal);\n        }\n        if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n            traversal = traverseArray(function (val) { return val; }, traversal);\n        }\n        if (traversal === null)\n            throw new Error('BUG: unexpected empty traversal');\n        return traversal.build(base);\n    },\n    this_attr: function (p) {\n        var name = p.processString();\n        if (name === 'null') {\n            return { type: 'Value', value: null };\n        }\n        if (name === 'true') {\n            return { type: 'Value', value: true };\n        }\n        if (name === 'false') {\n            return { type: 'Value', value: false };\n        }\n        return {\n            type: 'AccessAttribute',\n            name: name\n        };\n    },\n    neg: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Neg',\n            base: base\n        };\n    },\n    pos: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Pos',\n            base: base\n        };\n    },\n    add: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '+',\n            left: left,\n            right: right\n        };\n    },\n    sub: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '-',\n            left: left,\n            right: right\n        };\n    },\n    mul: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '*',\n            left: left,\n            right: right\n        };\n    },\n    div: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '/',\n            left: left,\n            right: right\n        };\n    },\n    mod: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '%',\n            left: left,\n            right: right\n        };\n    },\n    pow: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '**',\n            left: left,\n            right: right\n        };\n    },\n    comp: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var op = p.processString();\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: op,\n            left: left,\n            right: right\n        };\n    },\n    in_range: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'InRange',\n            base: base,\n            left: left,\n            right: right,\n            isInclusive: isInclusive\n        };\n    },\n    str: function (p) {\n        var value = '';\n        // eslint-disable-next-line no-labels\n        loop: while (p.hasMark()) {\n            var mark = p.getMark();\n            switch (mark.name) {\n                case 'str_end':\n                    value += p.processStringEnd();\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                case 'str_pause':\n                    value += p.processStringEnd();\n                    break;\n                case 'str_start':\n                    p.shift();\n                    break;\n                case 'single_escape': {\n                    var char = p.slice(1);\n                    p.shift();\n                    value += ESCAPE_SEQUENCE[char];\n                    break;\n                }\n                case 'unicode_hex':\n                    p.shift();\n                    value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(\"unexpected mark: \".concat(mark.name));\n            }\n        }\n        return { type: 'Value', value: value };\n    },\n    integer: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    float: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    sci: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    object: function (p) {\n        var attributes = [];\n        while (p.getMark().name !== 'object_end') {\n            attributes.push(p.process(OBJECT_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Object',\n            attributes: attributes\n        };\n    },\n    array: function (p) {\n        var elements = [];\n        while (p.getMark().name !== 'array_end') {\n            var isSplat = false;\n            if (p.getMark().name === 'array_splat') {\n                isSplat = true;\n                p.shift();\n            }\n            var value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: 'ArrayElement',\n                value: value,\n                isSplat: isSplat\n            });\n        }\n        p.shift();\n        return {\n            type: 'Array',\n            elements: elements\n        };\n    },\n    tuple: function (p) {\n        var members = [];\n        while (p.getMark().name !== 'tuple_end') {\n            members.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Tuple',\n            members: members\n        };\n    },\n    func_call: function (p) {\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        var name = p.processString();\n        if (namespace === 'global' && name === 'select') {\n            var result = {\n                type: 'Select',\n                alternatives: []\n            };\n            while (p.getMark().name !== 'func_args_end') {\n                if (p.getMark().name === 'pair') {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    p.shift();\n                    var condition = p.process(EXPR_BUILDER);\n                    var value = p.process(EXPR_BUILDER);\n                    result.alternatives.push({\n                        type: 'SelectAlternative',\n                        condition: condition,\n                        value: value\n                    });\n                }\n                else {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    var value = p.process(EXPR_BUILDER);\n                    result.fallback = value;\n                }\n            }\n            p.shift();\n            return result;\n        }\n        var args = [];\n        while (p.getMark().name !== 'func_args_end') {\n            if (argumentShouldBeSelector(namespace, name, args.length)) {\n                // Since the diff/delta functions aren't validated yet we only want to validate the selector\n                // being used. We expect the null valued arg to throw an error at evaluation time.\n                p.process(SELECTOR_BUILDER);\n                args.push({ type: 'Selector' });\n            }\n            else {\n                args.push(p.process(EXPR_BUILDER));\n            }\n        }\n        p.shift();\n        if (namespace === 'global' && (name === 'before' || name === 'after')) {\n            if (p.parseOptions.mode === 'delta') {\n                return {\n                    type: 'Context',\n                    key: name\n                };\n            }\n        }\n        if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n            throw new GroqQueryError('unexpected boost');\n        var funcs = namespaces[namespace];\n        if (!funcs) {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var func = funcs[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        if (func.arity !== undefined) {\n            validateArity(name, func.arity, args.length);\n        }\n        if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        return {\n            type: 'FuncCall',\n            func: func,\n            name: name,\n            args: args\n        };\n    },\n    pipecall: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        p.shift(); // Remove the func_call\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        if (namespace !== 'global') {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var name = p.processString();\n        var args = [];\n        var oldAllowBoost = p.allowBoost;\n        if (name === 'score') {\n            // Only allow boost inside a score expression\n            p.allowBoost = true;\n        }\n        for (;;) {\n            var markName = p.getMark().name;\n            if (markName === 'func_args_end') {\n                break;\n            }\n            if (name === 'order') {\n                if (markName === 'asc') {\n                    p.shift();\n                    args.push({ type: 'Asc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n                else if (markName === 'desc') {\n                    p.shift();\n                    args.push({ type: 'Desc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        p.allowBoost = oldAllowBoost;\n        var func = pipeFunctions[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n        }\n        if (func.arity) {\n            validateArity(name, func.arity, args.length);\n        }\n        return {\n            type: 'PipeFuncCall',\n            func: func,\n            base: base,\n            name: name,\n            args: args\n        };\n    },\n    pair: function (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'And',\n            left: left,\n            right: right\n        };\n    },\n    or: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'Or',\n            left: left,\n            right: right\n        };\n    },\n    not: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Not',\n            base: base\n        };\n    },\n    asc: function (p) {\n        throw new GroqQueryError('unexpected asc');\n    },\n    desc: function (p) {\n        throw new GroqQueryError('unexpected desc');\n    },\n    param: function (p) {\n        var name = p.processString();\n        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n            return {\n                type: 'Value',\n                value: p.parseOptions.params[name]\n            };\n        }\n        return {\n            type: 'Parameter',\n            name: name\n        };\n    }\n};\nvar OBJECT_BUILDER = {\n    object_expr: function (p) {\n        if (p.getMark().name === 'pair') {\n            p.shift();\n            var condition = p.process(EXPR_BUILDER);\n            var value_1 = p.process(EXPR_BUILDER);\n            return {\n                type: 'ObjectConditionalSplat',\n                condition: condition,\n                value: value_1\n            };\n        }\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: extractPropertyKey(value),\n            value: value\n        };\n    },\n    object_pair: function (p) {\n        var name = p.process(EXPR_BUILDER);\n        if (name.type !== 'Value')\n            throw new Error('name must be string');\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: name.value,\n            value: value\n        };\n    },\n    object_splat: function (p) {\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectSplat',\n            value: value\n        };\n    },\n    object_splat_this: function () {\n        return {\n            type: 'ObjectSplat',\n            value: { type: 'This' }\n        };\n    }\n};\nvar TRAVERSE_BUILDER = {\n    square_bracket: function (p) {\n        var expr = p.process(EXPR_BUILDER);\n        var value = tryConstantEvaluate(expr);\n        if (value && value.type === 'number') {\n            return function (right) {\n                return traverseElement(function (base) { return ({ type: 'AccessElement', base: base, index: value.data }); }, right);\n            };\n        }\n        if (value && value.type === 'string') {\n            return function (right) {\n                return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: value.data }); }, right);\n            };\n        }\n        return function (right) {\n            return traverseArray(function (base) { return ({\n                type: 'Filter',\n                base: base,\n                expr: expr\n            }); }, right);\n        };\n    },\n    slice: function (p) {\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        var leftValue = tryConstantEvaluate(left);\n        var rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n            throw new GroqQueryError('slicing must use constant numbers');\n        }\n        return function (rhs) {\n            return traverseArray(function (base) { return ({\n                type: 'Slice',\n                base: base,\n                left: leftValue.data,\n                right: rightValue.data,\n                isInclusive: isInclusive\n            }); }, rhs);\n        };\n    },\n    projection: function (p) {\n        var obj = p.process(EXPR_BUILDER);\n        return function (right) {\n            return traverseProjection(function (base) { return ({ type: 'Projection', base: base, expr: obj }); }, right);\n        };\n    },\n    attr_access: function (p) {\n        var name = p.processString();\n        return function (right) { return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: name }); }, right); };\n    },\n    deref: function (p) {\n        var attr = null;\n        if (p.getMark().name === 'deref_attr') {\n            p.shift();\n            attr = p.processString();\n        }\n        var wrap = function (base) {\n            return attr ? { type: 'AccessAttribute', base: base, name: attr } : base;\n        };\n        return function (right) {\n            return traversePlain(function (base) {\n                return wrap({\n                    type: 'Deref',\n                    base: base\n                });\n            }, right);\n        };\n    },\n    array_postfix: function (p) {\n        return function (right) { return traverseArray(function (base) { return ({ type: 'ArrayCoerce', base: base }); }, right); };\n    }\n};\nvar SELECTOR_BUILDER = {\n    group: function (p) {\n        p.process(SELECTOR_BUILDER);\n        return null;\n    },\n    everything: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    \"this\": function () {\n        throw new Error('Invalid selector syntax');\n    },\n    parent: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    dblparent: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    traverse: function (p) {\n        p.process(SELECTOR_BUILDER);\n        while (p.getMark().name !== 'traversal_end') {\n            p.process(TRAVERSE_BUILDER);\n        }\n        p.shift();\n        return null;\n    },\n    this_attr: function (p) {\n        p.processString();\n        return null;\n    },\n    neg: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pos: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    add: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sub: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mul: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    div: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mod: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pow: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    comp: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    in_range: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    str: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    integer: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    float: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sci: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    object: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    array: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    tuple: function (p) {\n        // This should only throw an error until we add support for tuples in selectors.\n        throw new Error('Invalid selector syntax');\n    },\n    func_call: function (p, mark) {\n        var func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === 'anywhere' && func.args.length === 1)\n            return null;\n        throw new Error('Invalid selector syntax');\n    },\n    pipecall: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pair: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    and: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    or: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    not: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    asc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    desc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    param: function (p) {\n        throw new Error('Invalid selector syntax');\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === 'AccessAttribute' && !node.base) {\n        return node.name;\n    }\n    if (node.type === 'Deref' ||\n        node.type === 'Map' ||\n        node.type === 'Projection' ||\n        node.type === 'Slice' ||\n        node.type === 'Filter' ||\n        node.type === 'AccessElement' ||\n        node.type === 'ArrayCoerce') {\n        return extractPropertyKey(node.base);\n    }\n    throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity === 'number') {\n        if (count !== arity) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n        }\n    }\n    else if (arity) {\n        if (!arity(count)) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n        }\n    }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    var functionsRequiringSelectors = ['changedAny', 'changedOnly'];\n    return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nvar GroqSyntaxError = /** @class */ (function (_super) {\n    __extends(GroqSyntaxError, _super);\n    function GroqSyntaxError(position) {\n        var _this = _super.call(this, \"Syntax error in GROQ query at position \".concat(position)) || this;\n        _this.name = 'GroqSyntaxError';\n        _this.position = position;\n        return _this;\n    }\n    return GroqSyntaxError;\n}(Error));\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nfunction parse(input, options) {\n    if (options === void 0) { options = {}; }\n    var result = parse$1(input);\n    if (result.type === 'error') {\n        throw new GroqSyntaxError(result.position);\n    }\n    var processor = new MarkProcessor(input, result.marks, options);\n    return processor.process(EXPR_BUILDER);\n}exports.evaluate=evaluateQuery;exports.parse=parse;Object.defineProperty(exports,'__esModule',{value:true});}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEudW1kLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQXNELFlBQVksQ0FBZ0ksRUFBRSwwQkFBMEIsYUFBYTtBQUMxUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1RkFBdUYsY0FBYztBQUN0SCx1QkFBdUIsZ0NBQWdDLHFDQUFxQywyQ0FBMkM7QUFDdkksNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLHlCQUF5QixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsSUFBSSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUMsR0FBRztBQUNyQyw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQkFBMkIsc0NBQXNDLHdCQUF3QixPQUFPO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrRkFBK0Y7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxzQ0FBc0M7QUFDN0c7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHdFQUF3RSxjQUFjO0FBQ3RGO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQixvQkFBb0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNkJBQTZCO0FBQy9FO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRCxRQUFRO0FBQ1IsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxXQUFXLHNDQUFzQztBQUNqRCxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsbUNBQW1DO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0NBQXNDO0FBQ3JELGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsd0JBQXdCLCtCQUErQixHQUFHLHVDQUF1QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RCxvQkFBb0IsK0JBQStCLEdBQUcsa0NBQWtDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hELG9CQUFvQiwrQkFBK0IsR0FBRyx1Q0FBdUM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIscUNBQXFDO0FBQ2xFLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlELDBCQUEwQiwrQkFBK0IsR0FBRyx1Q0FBdUM7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsd0JBQXdCLCtCQUErQixHQUFHLHVDQUF1QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUEsb0JBQW9CLGtDQUFrQztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyxrQ0FBa0M7QUFDN0MsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsaUJBQWlCLDJDQUEyQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw4QkFBOEIsdUNBQXVDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNDQUFzQzs7QUFFcEQ7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3RELGdCQUFnQixrQ0FBa0MsR0FBRyxpQ0FBaUM7QUFDdEY7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixnQkFBZ0IsNkJBQTZCLEdBQUcsMkNBQTJDO0FBQzNGO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKLGdCQUFnQixrQ0FBa0MsR0FBRyxpQ0FBaUM7QUFDdEY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGNBQWMseUNBQXlDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIsWUFBWTtBQUNaOztBQUVBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0MsZ0JBQWdCO0FBQ2hCLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0EsaUNBQWlDO0FBQ2pDLHdCQUF3Qix1Q0FBdUM7QUFDL0QsZ0NBQWdDO0FBQ2hDLHdCQUF3Qix1Q0FBdUM7QUFDL0QsWUFBWTtBQUNaLHdCQUF3Qix1Q0FBdUM7QUFDL0Qsd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNCQUFzQix5Q0FBeUM7QUFDL0Q7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSx1Q0FBdUMsY0FBYyxHQUFHO0FBQy9GO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSwyQ0FBMkMsY0FBYyxHQUFHO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQ0FBMkMsZUFBZTtBQUMxRCwyQ0FBMkMsZUFBZTtBQUMxRCwyQ0FBMkMsZUFBZTtBQUMxRCw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQXNELFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJLElBQUk7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEIsbUVBQW1FO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBNEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVSxzREFBc0QsSUFBSTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVLHVEQUF1RCxJQUFJO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVLDJDQUEyQyxJQUFJO0FBQ2pIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0MsdUNBQXVDLFVBQVUsaURBQWlELElBQUk7QUFDeEksS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtEQUFrRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLHVDQUF1QyxVQUFVLGlDQUFpQyxJQUFJO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQixvQkFBb0IsNENBQTRDLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEudW1kLmNqcz80NTY5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihnLGYpe3R5cGVvZiBleHBvcnRzPT09J29iamVjdCcmJnR5cGVvZiBtb2R1bGUhPT0ndW5kZWZpbmVkJz9mKGV4cG9ydHMpOnR5cGVvZiBkZWZpbmU9PT0nZnVuY3Rpb24nJiZkZWZpbmUuYW1kP2RlZmluZShbJ2V4cG9ydHMnXSxmKTooZz10eXBlb2YgZ2xvYmFsVGhpcyE9PSd1bmRlZmluZWQnP2dsb2JhbFRoaXM6Z3x8c2VsZixmKGdbXCIxXCJdPXt9KSk7fSkodGhpcywoZnVuY3Rpb24oZXhwb3J0cyl7J3VzZSBzdHJpY3QnOy8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX192YWx1ZXMobykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9fYXdhaXQodikge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufVxuXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59dmFyIE1hcmtQcm9jZXNzb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFya1Byb2Nlc3NvcihzdHJpbmcsIG1hcmtzLCBwYXJzZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hbGxvd0Jvb3N0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbiAgICB9XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUuaGFzTWFyayA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdm9pZCAwKSB7IHBvcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggKyBwb3MgPCB0aGlzLm1hcmtzLmxlbmd0aDtcbiAgICB9O1xuICAgIE1hcmtQcm9jZXNzb3IucHJvdG90eXBlLmdldE1hcmsgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT09IHZvaWQgMCkgeyBwb3MgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICB9O1xuICAgIE1hcmtQcm9jZXNzb3IucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2YXIgbWFyayA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XG4gICAgICAgIHRoaXMuc2hpZnQoKTtcbiAgICAgICAgdmFyIGZ1bmMgPSB2aXNpdG9yW21hcmsubmFtZV07XG4gICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBoYW5kbGVyOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh2aXNpdG9yLCB0aGlzLCBtYXJrKTtcbiAgICB9O1xuICAgIE1hcmtQcm9jZXNzb3IucHJvdG90eXBlLnByb2Nlc3NTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgICAgICB0aGlzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwcmV2LnBvc2l0aW9uLCBjdXJyLnBvc2l0aW9uKTtcbiAgICB9O1xuICAgIE1hcmtQcm9jZXNzb3IucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XS5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXJrUHJvY2Vzc29yO1xufSgpKTt2YXIgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcbmZ1bmN0aW9uIHBhcnNlUkZDMzMzOShzdHIpIHtcbiAgICBpZiAoUkZDMzMzOV9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XG4gICAgdmFyIHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpO1xuICAgIHZhciBtb250aCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTW9udGgoKSArIDEsIDIpO1xuICAgIHZhciBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMik7XG4gICAgdmFyIGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpO1xuICAgIHZhciBtaW51dGUgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01pbnV0ZXMoKSwgMik7XG4gICAgdmFyIHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbiAgICB2YXIgZnJhY3Rpb25hbFNlY29uZCA9ICcnO1xuICAgIHZhciBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIGlmIChtaWxsaXMgIT0gMCkge1xuICAgICAgICBmcmFjdGlvbmFsU2Vjb25kID0gXCIuXCIuY29uY2F0KGFkZExlYWRpbmdaZXJvKG1pbGxpcywgMykpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoeWVhciwgXCItXCIpLmNvbmNhdChtb250aCwgXCItXCIpLmNvbmNhdChkYXksIFwiVFwiKS5jb25jYXQoaG91ciwgXCI6XCIpLmNvbmNhdChtaW51dGUsIFwiOlwiKS5jb25jYXQoc2Vjb25kKS5jb25jYXQoZnJhY3Rpb25hbFNlY29uZCwgXCJaXCIpO1xufVxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtLCB0YXJnZXRMZW5ndGgpIHtcbiAgICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgc3RyID0gXCIwXCIuY29uY2F0KHN0cik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59ZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICAgIHZhciByZSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBwYXR0ZXJuLnNwbGl0KCcuJyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xuICAgICAgICBpZiAocGFydCA9PT0gJyonKSB7XG4gICAgICAgICAgICByZS5wdXNoKCdbXi5dKycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnQgPT09ICcqKicpIHtcbiAgICAgICAgICAgIHJlLnB1c2goJy4qJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHJlLmpvaW4oJy4nKSwgXCIkXCIpKTtcbn1cbnZhciBQYXRoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGgocGF0dGVybikge1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gICAgfVxuICAgIFBhdGgucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm5SZS50ZXN0KHN0cik7XG4gICAgfTtcbiAgICBQYXRoLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gICAgfTtcbiAgICByZXR1cm4gUGF0aDtcbn0oKSk7dmFyIFN0cmVhbVZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmVhbVZhbHVlKGdlbmVyYXRvcikge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RyZWFtJztcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIHRoaXMudGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgU3RyZWFtVmFsdWUucHJvdG90eXBlLmlzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3RyZWFtVmFsdWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIF9iLCBfYywgdmFsdWUsIF9kLCBfZSwgZV8xXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2YudHJ5cy5wdXNoKFsxLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBfX2FzeW5jVmFsdWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9jID0gX2Yuc2VudCgpLCAhX2MuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gKF9kID0gcmVzdWx0KS5wdXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5hcHBseShfZCwgW19mLnNlbnQoKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYltcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKF9iKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0cmVhbVZhbHVlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gX2EoKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCB0aGlzLmRhdGEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHRoaXMuZGF0YVtpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0RvbmUpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2b2lkIDApXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHRoaXMuX25leHRUaWNrKCkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHJlYW1WYWx1ZS5wcm90b3R5cGUuX25leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy50aWNrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFJlc29sdmVyO1xuICAgICAgICB2YXIgc2V0dXBUaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aWNrZXIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcbiAgICAgICAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmZXRjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIHZhbHVlLCBlXzJfMTtcbiAgICAgICAgICAgIHZhciBlXzIsIF9jO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFswLCA1LCA2LCAxMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfX2FzeW5jVmFsdWVzKHRoaXMuZ2VuZXJhdG9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9iID0gX2Quc2VudCgpLCAhX2IuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMl8xID0gX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFs2LCAsIDksIDEwXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfYiAmJiAhX2IuZG9uZSAmJiAoX2MgPSBfYVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLmNhbGwoX2EpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgICAgIGZldGNoKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICB9O1xuICAgIHJldHVybiBTdHJlYW1WYWx1ZTtcbn0oKSk7dmFyIFN0YXRpY1ZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY1ZhbHVlKGRhdGEsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgU3RhdGljVmFsdWUucHJvdG90eXBlLmlzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdhcnJheSc7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIFN0YXRpY1ZhbHVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5kYXRhXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0YXRpY1ZhbHVlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2ksIGRhdGFfMSwgZWxlbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIGRhdGFfMSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgZGF0YV8xLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkYXRhXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZyb21KUyhlbGVtZW50KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGl0ZXJhdGUgb3ZlcjogXCIuY29uY2F0KHRoaXMudHlwZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1ZhbHVlO1xufSgpKTtcbnZhciBOVUxMX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKG51bGwsICdudWxsJyk7XG52YXIgVFJVRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZSh0cnVlLCAnYm9vbGVhbicpO1xudmFyIEZBTFNFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKGZhbHNlLCAnYm9vbGVhbicpO1xudmFyIERhdGVUaW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGVUaW1lKGRhdGUpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgICB9XG4gICAgRGF0ZVRpbWUucGFyc2VUb1ZhbHVlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksICdkYXRldGltZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH07XG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSA9PSBvdGhlci5kYXRlLmdldFRpbWUoKTtcbiAgICB9O1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoc2Vjcykge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICBjb3B5LnNldFRpbWUoY29weS5nZXRUaW1lKCkgKyBzZWNzICogMTAwMCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoY29weSk7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgIH07XG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICAgIH07XG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0UkZDMzMzOSh0aGlzLmRhdGUpO1xuICAgIH07XG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlVGltZTtcbn0oKSk7XG5mdW5jdGlvbiBmcm9tTnVtYmVyKG51bSkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG51bSwgJ251bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsICdzdHJpbmcnKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsICdkYXRldGltZScpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUocGF0aCwgJ3BhdGgnKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT09ICdmdW5jdGlvbic7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gZnJvbUpTKHZhbCkge1xuICAgIGlmIChpc0l0ZXJhdG9yKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsXzEsIHZhbF8xXzEsIHZhbHVlLCBlXzFfMTtcbiAgICAgICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzAsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsXzEgPSBfX2FzeW5jVmFsdWVzKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbF8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbF8xXzEgPSBfYi5zZW50KCksICF2YWxfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChmcm9tSlModmFsdWUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsXzFfMSAmJiAhdmFsXzFfMS5kb25lICYmIChfYSA9IHZhbF8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9hLmNhbGwodmFsXzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGdldFR5cGUoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgIHJldHVybiAncGF0aCc7XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRldGltZSc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgZGF0YTtcbn12YXIgVFlQRV9PUkRFUiA9IHtcbiAgICBkYXRldGltZTogMSxcbiAgICBudW1iZXI6IDIsXG4gICAgc3RyaW5nOiAzLFxuICAgIGJvb2xlYW46IDRcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gcGFydGlhbENvbXBhcmUoYSwgYikge1xuICAgIHZhciBhVHlwZSA9IGdldFR5cGUoYSk7XG4gICAgdmFyIGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFUeXBlKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgaWYgKGEgPCBiKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChhID4gYilcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gdG90YWxDb21wYXJlKGEsIGIpIHtcbiAgICB2YXIgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICAgIHZhciBiVHlwZSA9IGdldFR5cGUoYik7XG4gICAgdmFyIGFUeXBlT3JkZXIgPSBUWVBFX09SREVSW2FUeXBlXSB8fCAxMDA7XG4gICAgdmFyIGJUeXBlT3JkZXIgPSBUWVBFX09SREVSW2JUeXBlXSB8fCAxMDA7XG4gICAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufXZhciBDSEFSUyA9IC8oW14hQCMkJV4mKigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xudmFyIENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xudmFyIEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbnZhciBNQVhfVEVSTV9MRU5HVEggPSAxMDI0O1xuZnVuY3Rpb24gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybnMuZXZlcnkoZnVuY3Rpb24gKHBhdHRlcm4pIHsgcmV0dXJuIHBhdHRlcm4odG9rZW5zKTsgfSk7XG59XG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsICcnKS5tYXRjaChDSEFSUykgfHwgW107XG59XG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQpIHtcbiAgICB2YXIgdGVybXNSZSA9IG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpO1xuICAgIHJldHVybiB0ZXJtc1JlLm1hcChmdW5jdGlvbiAocmUpIHsgcmV0dXJuIGZ1bmN0aW9uICh0b2tlbnMpIHsgcmV0dXJuIHRva2Vucy5zb21lKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gcmUudGVzdCh0b2tlbik7IH0pOyB9OyB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcbiAgICB2YXIgdGVybXMgPSB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgJycpLm1hdGNoKENIQVJTX1dJVEhfV0lMRENBUkQpIHx8IFtdO1xuICAgIHJldHVybiB0ZXJtcy5tYXAoZnVuY3Rpb24gKHRlcm0pIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHRlcm0uc2xpY2UoMCwgTUFYX1RFUk1fTEVOR1RIKS5yZXBsYWNlKC9cXCovZywgJy4qJyksIFwiJFwiKSwgJ2knKTsgfSk7XG59XG5mdW5jdGlvbiBnYXRoZXJUZXh0KHZhbHVlLCBjYikge1xuICAgIHZhciB2YWx1ZV8xLCB2YWx1ZV8xXzE7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3VjY2VzcywgcGFydCwgZV8xXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IodmFsdWUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgNiwgNywgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVfMSA9IF9fYXN5bmNWYWx1ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZV8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8xXzEgPSBfYi5zZW50KCksICF2YWx1ZV8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gdmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IocGFydC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzcsICwgMTAsIDExXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSAmJiAhdmFsdWVfMV8xLmRvbmUgJiYgKF9hID0gdmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbCh2YWx1ZV8xKV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgc3VjY2Vzc107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59Ly8gQk0yNSBzaW1pbGFyaXR5IGNvbnN0YW50c1xudmFyIEJNMjVrID0gMS4yO1xuZnVuY3Rpb24gZXZhbHVhdGVTY29yZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyU2NvcmUsIGJvb3N0LCBfYSwgbGVmdFNjb3JlLCByaWdodFNjb3JlLCBsZWZ0U2NvcmUsIHJpZ2h0U2NvcmUsIHJlcztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ09wQ2FsbCcgJiYgbm9kZS5vcCA9PT0gJ21hdGNoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV2YWx1YXRlTWF0Y2hTY29yZShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZS50eXBlID09PSAnRnVuY0NhbGwnICYmIG5vZGUubmFtZSA9PT0gJ2Jvb3N0JykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKG5vZGUuYXJnc1swXSwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlubmVyU2NvcmUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobm9kZS5hcmdzWzFdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYm9vc3QgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib29zdC50eXBlID09PSAnbnVtYmVyJyAmJiBpbm5lclNjb3JlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGlubmVyU2NvcmUgKyBib29zdC5kYXRhXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgMF07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfYSA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT3InOiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0FuZCc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbGVmdFNjb3JlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByaWdodFNjb3JlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGVmdFNjb3JlICsgcmlnaHRTY29yZV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGxlZnRTY29yZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRTY29yZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRTY29yZSA9PT0gMCB8fCByaWdodFNjb3JlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGVmdFNjb3JlICsgcmlnaHRTY29yZV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShub2RlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlcy50eXBlID09PSAnYm9vbGVhbicgJiYgcmVzLmRhdGEgPT09IHRydWUgPyAxIDogMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlKGxlZnQsIHJpZ2h0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRleHQsIHBhdHRlcm4sIHRva2VucywgdGVybXMsIGRpZFN1Y2NlZWQsIHNjb3JlLCBfbG9vcF8xLCBfaSwgdGVybXNfMSwgcmU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobGVmdCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUocmlnaHQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGVybXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2F0aGVyVGV4dCh0ZXh0LCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdhdGhlclRleHQocGF0dGVybiwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChtYXRjaFBhdHRlcm5SZWdleChwYXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBkaWRTdWNjZWVkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpZFN1Y2NlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0ZXJtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY29yZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVxID0gdG9rZW5zLnJlZHVjZShmdW5jdGlvbiAoYywgdG9rZW4pIHsgcmV0dXJuIGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCk7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmUgKz0gKGZyZXEgKiAoQk0yNWsgKyAxKSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIHRlcm1zXzEgPSB0ZXJtczsgX2kgPCB0ZXJtc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmUgPSB0ZXJtc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEocmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzY29yZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufWZ1bmN0aW9uIHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0cztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUudHlwZSA9PT0gJ29iamVjdCcpKSByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGFycmF5VGV4dCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGV4dHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGV4dHMuam9pbignXFxuXFxuJyldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhcnJheVRleHQodmFsdWUsIHJlc3VsdCkge1xuICAgIHZhciB2YWx1ZV8xLCB2YWx1ZV8xXzE7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IFtdOyB9XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmxvY2ssIHRleHQsIGVfMV8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzAsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXzEgPSBfX2FzeW5jVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWVfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xID0gX2Iuc2VudCgpLCAhdmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSB2YWx1ZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJsb2NrLnR5cGUgPT09ICdvYmplY3QnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBibG9ja1RleHQoYmxvY2suZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFibG9jay5pc0FycmF5KCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSAmJiAhdmFsdWVfMV8xLmRvbmUgJiYgKF9hID0gdmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwodmFsdWVfMSldO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmouX3R5cGUgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIF9pID0gMCwgY2hpbGRyZW5fMSA9IGNoaWxkcmVuOyBfaSA8IGNoaWxkcmVuXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuXzFbX2ldO1xuICAgICAgICBpZiAoY2hpbGQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjaGlsZC5fdHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGNoaWxkLl90eXBlID09PSAnc3BhbicgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjaGlsZC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1mdW5jdGlvbiBoYXNSZWZlcmVuY2UodmFsdWUsIHBhdGhTZXQpIHtcbiAgICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdmFsdWVfMSA9IHZhbHVlOyBfaSA8IHZhbHVlXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZV8xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKHZhbHVlLl9yZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gT2JqZWN0LnZhbHVlcyh2YWx1ZSk7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRVVEY4KHN0cikge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBIaWdoIHN1cnJvZ2F0ZS4gRG9uJ3QgY291bnQgdGhpcy5cbiAgICAgICAgICAgIC8vIEJ5IG9ubHkgY291bnRpbmcgdGhlIGxvdyBzdXJyb2dhdGUgd2Ugd2lsbCBjb3JyZWN0bHlcbiAgICAgICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgVVRGLTggY29kZSBwb2ludHMuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG52YXIgZ2xvYmFsID0ge307XG5nbG9iYWwuYW55d2hlcmUgPSBmdW5jdGlvbiBhbnl3aGVyZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5hbnl3aGVyZS5hcml0eSA9IDE7XG5nbG9iYWwuY29hbGVzY2UgPSBmdW5jdGlvbiBjb2FsZXNjZShhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9pLCBhcmdzXzEsIGFyZywgdmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYXJnc18xID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBhcmdzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5jb3VudCA9IGZ1bmN0aW9uIGNvdW50KGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXIsIG51bSwgaW5uZXJfMSwgaW5uZXJfMV8xLCBlXzFfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbnVtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICBpbm5lcl8xID0gX19hc3luY1ZhbHVlcyhpbm5lcik7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGlubmVyXzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyXzFfMSA9IF9iLnNlbnQoKSwgIWlubmVyXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGlubmVyXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJfMV8xICYmICFpbm5lcl8xXzEuZG9uZSAmJiAoX2EgPSBpbm5lcl8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChpbm5lcl8xKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tTnVtYmVyKG51bSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuY291bnQuYXJpdHkgPSAxO1xuZ2xvYmFsLmRhdGVUaW1lID0gZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIERhdGVUaW1lLnBhcnNlVG9WYWx1ZSh2YWwuZGF0YSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuZ2xvYmFsLmRlZmluZWQgPSBmdW5jdGlvbiBkZWZpbmVkKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlubmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaW5uZXIudHlwZSA9PT0gJ251bGwnID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmRlZmluZWQuYXJpdHkgPSAxO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbmdsb2JhbC5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KGFyZ3MsIHNjb3BlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LmlkZW50aXR5KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5nbG9iYWwubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXIsIG51bSwgaW5uZXJfMiwgaW5uZXJfMl8xLCBlXzJfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIoY291bnRVVEY4KGlubmVyLmRhdGEpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbm5lci5pc0FycmF5KCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICBpbm5lcl8yID0gX19hc3luY1ZhbHVlcyhpbm5lcik7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGlubmVyXzIubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyXzJfMSA9IF9iLnNlbnQoKSwgIWlubmVyXzJfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGlubmVyXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgZV8yXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJfMl8xICYmICFpbm5lcl8yXzEuZG9uZSAmJiAoX2EgPSBpbm5lcl8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChpbm5lcl8yKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tTnVtYmVyKG51bSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XG5nbG9iYWwucGF0aCA9IGZ1bmN0aW9uIHBhdGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwucGF0aC5hcml0eSA9IDE7XG5nbG9iYWwuc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoXCJcIi5jb25jYXQodmFsdWUuZGF0YSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5nbG9iYWwucmVmZXJlbmNlcyA9IGZ1bmN0aW9uIHJlZmVyZW5jZXMoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoU2V0LCBfaSwgYXJnc18yLCBhcmcsIHBhdGgsIHBhdGhfMSwgcGF0aF8xXzEsIGVsZW0sIGVfM18xLCBzY29wZVZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBwYXRoU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIGFyZ3NfMiA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgYXJnc18yLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc18yW19pXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmcsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXRoLnR5cGUgPT09ICdzdHJpbmcnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHBhdGhTZXQuYWRkKHBhdGguZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0aC5pc0FycmF5KCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs0LCA5LCAxMCwgMTVdKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aF8xID0gKGVfMyA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyhwYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIHBhdGhfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGF0aF8xXzEgPSBfYi5zZW50KCksICFwYXRoXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBwYXRoXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhTZXQuYWRkKGVsZW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBlXzNfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8zID0geyBlcnJvcjogZV8zXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMTAsICwgMTMsIDE0XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhdGhfMV8xICYmICFwYXRoXzFfMS5kb25lICYmIChfYSA9IHBhdGhfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwocGF0aF8xKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEyO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aFNldC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNjb3BlLnZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICBzY29wZVZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaGFzUmVmZXJlbmNlKHNjb3BlVmFsdWUsIHBhdGhTZXQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyA+PSAxOyB9O1xuZ2xvYmFsLnJvdW5kID0gZnVuY3Rpb24gcm91bmQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgbnVtLCBwcmVjLCBwcmVjVmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBudW0gPSB2YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBwcmVjID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXJncy5sZW5ndGggPT09IDIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcHJlY1ZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlY1ZhbHVlLnR5cGUgIT09ICdudW1iZXInIHx8IHByZWNWYWx1ZS5kYXRhIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihwcmVjVmFsdWUuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmVjID0gcHJlY1ZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVjID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEphdmFTY3JpcHQncyByb3VuZCgpIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJvdW5kcyB0b3dhcmRzIHBvc2l0aXZlIGluZmluaXR5ICgtMy41IC0+IC0zKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmVoYXZpb3Igd2UncmUgaW50ZXJlc3RlZCBpbiBpcyB0byBcInJvdW5kIGhhbGYgYXdheSBmcm9tIHplcm9cIi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIoTnVtYmVyKG51bS50b0ZpeGVkKHByZWMpKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwucm91bmQuYXJpdHkgPSBmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIGNvdW50ID49IDEgJiYgY291bnQgPD0gMjsgfTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG5nbG9iYWwubm93ID0gZnVuY3Rpb24gbm93KGFyZ3MsIHNjb3BlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5ub3cuYXJpdHkgPSAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbmdsb2JhbC5ib29zdCA9IGZ1bmN0aW9uIGJvb3N0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgc2NvcmluZyBmdW5jdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBib29zdCBjYWxsJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5ib29zdC5hcml0eSA9IDI7XG52YXIgc3RyaW5nID0ge307XG5zdHJpbmcubG93ZXIgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9Mb3dlckNhc2UoKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5zdHJpbmcubG93ZXIuYXJpdHkgPSAxO1xuc3RyaW5nLnVwcGVyID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuc3RyaW5nLnVwcGVyLmFyaXR5ID0gMTtcbmdsb2JhbC5sb3dlciA9IHN0cmluZy5sb3dlcjtcbmdsb2JhbC51cHBlciA9IHN0cmluZy51cHBlcjtcbnZhciBwdCA9IHt9O1xucHQudGV4dCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlLCB0ZXh0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyh0ZXh0KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbnB0LnRleHQuYXJpdHkgPSAxO1xudmFyIHNhbml0eSA9IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbnNhbml0eS5wcm9qZWN0SWQgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LnByb2plY3RJZCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuc2FuaXR5LmRhdGFzZXQgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xudmFyIHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBmdW5jdGlvbiBvcmRlcihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBiYXNlXzEsIGJhc2VfMV8xO1xuICAgIHZhciBlXzQsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcHBlcnMsIGRpcmVjdGlvbnMsIG4sIF9pLCBhcmdzXzMsIG1hcHBlciwgZGlyZWN0aW9uLCBhdXgsIGlkeCwgdmFsdWUsIG5ld1Njb3BlLCB0dXBsZSwgaSwgcmVzdWx0LCBfYiwgX2MsIGVfNF8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vcnBldHJpY2gvYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1hc3luYy10by1wcm9taXNlcy9pc3N1ZXMvNTlcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vcnBldHJpY2gvYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1hc3luYy10by1wcm9taXNlcy9pc3N1ZXMvNTlcbiAgICAgICAgICAgICAgICAgICAgX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2UuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFwcGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgYXJnc18zID0gYXJnczsgX2kgPCBhcmdzXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXIgPSBhcmdzXzNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2FzYyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVyLnR5cGUgPT09ICdEZXNjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdkZXNjJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBlci50eXBlID09PSAnQXNjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdXggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFsyLCAxMywgMTQsIDE5XSk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VfMSA9IF9fYXN5bmNWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8xXzEgPSBfZC5zZW50KCksICFiYXNlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHR1cGxlID0gW19kLnNlbnQoKSwgaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBuKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gKF9iID0gdHVwbGUpLnB1c2g7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3VsdC5nZXQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfYy5hcHBseShfYiwgW19kLnNlbnQoKV0pO1xuICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGF1eC5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMTE7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGVfNF8xID0gX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzQgPSB7IGVycm9yOiBlXzRfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFsxNCwgLCAxNywgMThdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8xXzEgJiYgIWJhc2VfMV8xLmRvbmUgJiYgKF9hID0gYmFzZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChiYXNlXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMTY7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgIGF1eC5zb3J0KGZ1bmN0aW9uIChhVHVwbGUsIGJUdXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1tpXSA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAtYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gc29ydGluZyBvbiB0aGUgb3JpZ2luYWwgaW5kZXggZm9yIHN0YWJsZSBzb3J0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoYXV4Lm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdlswXTsgfSkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gY291bnQgPj0gMTsgfTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG5waXBlRnVuY3Rpb25zLnNjb3JlID0gZnVuY3Rpb24gc2NvcmUoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgYmFzZV8yLCBiYXNlXzJfMTtcbiAgICB2YXIgZV81LCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bmtub3duLCBzY29yZWQsIHZhbHVlLCBfYiwgX2MsIG5ld1Njb3BlLCB2YWx1ZVNjb3JlLCBfaSwgYXJnc180LCBhcmcsIF9kLCBuZXdPYmplY3QsIGVfNV8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2UuaXNBcnJheSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbnl0aGluZyB0aGF0IGlzbid0IGFuIG9iamVjdCBzaG91bGQgYmUgc29ydGVkIGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93biA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzY29yZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2UudHJ5cy5wdXNoKFsxLCAxMiwgMTMsIDE4XSk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VfMiA9IF9fYXN5bmNWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VfMi5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8yXzEgPSBfZS5zZW50KCksICFiYXNlXzJfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZS50eXBlICE9PSAnb2JqZWN0JykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBfYyA9IChfYiA9IHVua25vd24pLnB1c2g7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF9jLmFwcGx5KF9iLCBbX2Uuc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PT0gJ251bWJlcicgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYXJnc180ID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBhcmdzXzQubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NfNFtfaV07XG4gICAgICAgICAgICAgICAgICAgIF9kID0gdmFsdWVTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShhcmcsIG5ld1Njb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNjb3JlID0gX2QgKyBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gODtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUuZGF0YSwgeyBfc2NvcmU6IHZhbHVlU2NvcmUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGVfNV8xID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzUgPSB7IGVycm9yOiBlXzVfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgX2UudHJ5cy5wdXNoKFsxMywgLCAxNiwgMTddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZV8yXzEgJiYgIWJhc2VfMl8xLmRvbmUgJiYgKF9hID0gYmFzZV8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChiYXNlXzIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTU7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLl9zY29yZSAtIGEuX3Njb3JlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhzY29yZWQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gY291bnQgPj0gMTsgfTtcbnZhciBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzQmVmb3JlLCBoYXNBZnRlcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaGFzQmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgIT09IG51bGw7XG4gICAgICAgICAgICBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzQmVmb3JlICYmIGhhc0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoJ3VwZGF0ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNBZnRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKCdjcmVhdGUnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoJ2RlbGV0ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gJ2RlbHRhJztcbmRlbHRhLmNoYW5nZWRPbmx5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZGVsdGEuY2hhbmdlZE9ubHkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZE9ubHkubW9kZSA9ICdkZWx0YSc7XG52YXIgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbnZhciBuYW1lc3BhY2VzID0ge1xuICAgIGdsb2JhbDogZ2xvYmFsLFxuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIHB0OiBwdCxcbiAgICBkZWx0YTogZGVsdGEsXG4gICAgZGlmZjogZGlmZixcbiAgICBzYW5pdHk6IHNhbml0eVxufTtjb25zdCBXUyA9IC9eKFtcXHRcXG5cXHZcXGZcXHIgXFx1MDA4NVxcdTAwQTBdfChcXC9cXC9bXlxcbl0qXFxuKSkrLztcbmNvbnN0IE5VTSA9IC9eXFxkKy87XG5jb25zdCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5cbi8vIFByZWNlZGVuY2UgbGV2ZWxzIGZvciBiaW5hcnkgb3BlcmF0b3JzOlxuY29uc3QgUFJFQ19QQUlSID0gMTtcbmNvbnN0IFBSRUNfT1IgPSAyO1xuY29uc3QgUFJFQ19BTkQgPSAzO1xuY29uc3QgUFJFQ19DT01QID0gNDtcbmNvbnN0IFBSRUNfT1JERVIgPSA0O1xuY29uc3QgUFJFQ19BREQgPSA2O1xuY29uc3QgUFJFQ19TVUIgPSA2O1xuY29uc3QgUFJFQ19NVUwgPSA3O1xuY29uc3QgUFJFQ19ESVYgPSA3O1xuY29uc3QgUFJFQ19NT0QgPSA3O1xuY29uc3QgUFJFQ19QT1cgPSA4O1xuXG4vLyBQcmVjZWRlbmNlIGxldmVscyBmb3IgcHJlZml4IG9wZXJhdG9yczpcbmNvbnN0IFBSRUNfUE9TID0gMTA7XG5jb25zdCBQUkVDX05PVCA9IDEwO1xuY29uc3QgUFJFQ19ORUcgPSA4O1xuXG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cbiAgZGVsZXRlIHJlc3VsdC5wb3NpdGlvbjtcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByKHN0ciwgcG9zLCBsZXZlbCkge1xuICAvLyBJbiB0aGlzIGZ1bmN0aW9uIHdlIHBhcnNlIHByZWNlZGVuY2UgXCJtYW51YWxseVwiIGJ5IGhhdmluZyB0d28gdmFyaWFibGVzOlxuICAvL1xuICAvLyBgbGV2ZWxgIGlzIHRoZSBtaW5pbXVtIHByZWNlZGVuY2UgbGV2ZWwgd2Ugd2FudCB0byBwYXJzZSBhdC4gSWYgdGhpcyBpc1xuICAvLyBlLmcuIDcgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IHBhcnNlIGAzICsgNGAgKHNpbmNlIGFkZGl0aW9uIGlzIGF0IDYpLFxuICAvLyBidXQgaW5zdGVhZCBqdXN0IHJldHVybiBgMWAgYW5kIGxlYXZlIGAgKyA1YCByZW1haW5pbmcuIFdlIHVzZSB0aGlzIHNvIHRoYXRcbiAgLy8gd2hpbGUgaGFuZGxpbmcgdGhlIFJIUyBvZiB0aGUgbXVsdGlwbGljYXRpb24gaW4gYDEgKyAyICogMyArIDRgIHdlIG9ubHkgcGFyc2UgYDNgLlxuICAvL1xuICAvLyBgbGhzTGV2ZWxgIGlzIHRoZSBwcmVjZWRlbmNlIGxldmVsIG9mIHRoZSBjdXJyZW50bHkgcGFyc2VkIGV4cHJlc3Npb24gb25cbiAgLy8gdGhlIGxlZnQtaGFuZCBzaWRlLiBUaGlzIGlzIG1haW5seSB1c2VkIHRvIGhhbmRsZSBub24tYXNzb2NpY2F0aXZlbmVzcy5cblxuICAvLyBUaGlzIG1lYW5zIHRoYXQgeW91J2xsIHNlZSBjb2RlIGxpa2U6XG4gIC8vIC0gYGlmIChsZXZlbCA+IFBSRUNfWFhYKSBicmVha2A6IE9wZXJhdG9yIGlzIGF0IHRoaXMgcHJlY2VkZW5jZSBsZXZlbC5cbiAgLy8gLSBgaWYgKGxoc0xldmVsIDwgUFJFQ19YWFgpIGJyZWFrYDogT3BlcmF0b3IgaXMgbGVmdC1hc3NvY2lhdGl2ZS5cbiAgLy8gLSBgaWYgKGxoc0xldmVsIDw9IFBSRUNfWFhYKSBicmVha2A6IE9wZXJhdG9yIGlzIHJpZ2h0L25vbi1hc3NvY2lhdGl2ZS5cbiAgLy8gLSBgcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX1hYWCArIDEpYDogT3BlcmF0b3IgaXMgbGVmdC9ub24tYXNzb2ljYXRlLlxuICAvLyAtIGBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfWFhYKWA6IE9wZXJhdG9yIGlzIHJpZ2h0LWFzc29pY2F0ZS5cblxuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBsZXQgbWFya3M7XG5cbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgJysnOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfUE9TKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgbWFya3MgPSBbe25hbWU6ICdwb3MnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJy0nOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTkVHKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgbWFya3MgPSBbe25hbWU6ICduZWcnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJygnOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlICcsJzoge1xuICAgICAgICAgIC8vIFR1cGxlc1xuICAgICAgICAgIG1hcmtzID0gW3tuYW1lOiAndHVwbGUnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJyknKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3R1cGxlX2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJyknOiB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MgPSBbe25hbWU6ICdncm91cCcsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICchJzoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX05PVCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAnbm90JywgcG9zaXRpb246IHN0YXJ0UG9zfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICd7Jzoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdbJzpcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAnYXJyYXknLCBwb3NpdGlvbjogcG9zfV07XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcblxuICAgICAgaWYgKHN0cltwb3NdICE9PSAnXScpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09ICcuLi4nKSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnYXJyYXlfc3BsYXQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXNcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJlcy5wb3NpdGlvbjtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJ10nKSBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gJ10nKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnYXJyYXlfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ14nOiB7XG4gICAgICBwb3MrKztcbiAgICAgIG1hcmtzID0gW107XG4gICAgICB3aGlsZSAoc3RyW3Bvc10gPT09ICcuJyAmJiBzdHJbcG9zICsgMV0gPT09ICdeJykge1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnZGJscGFyZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyArPSAyO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3BhcmVudCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnQCc6XG4gICAgICBtYXJrcyA9IFt7bmFtZTogJ3RoaXMnLCBwb3NpdGlvbjogc3RhcnRQb3N9XTtcbiAgICAgIHBvcysrO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICcqJzpcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAnZXZlcnl0aGluZycsIHBvc2l0aW9uOiBzdGFydFBvc31dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVha1xuICAgIGNhc2UgJyQnOiB7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSAxICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHtuYW1lOiAncGFyYW0nLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxfSxcbiAgICAgICAgICB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgbGV0IG51bUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICBpZiAobnVtTGVuKSB7XG4gICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgIGxldCBuYW1lID0gJ2ludGVnZXInO1xuXG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJy4nKSB7XG4gICAgICAgICAgbGV0IGZyYWNMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgTlVNKTtcbiAgICAgICAgICBpZiAoZnJhY0xlbikge1xuICAgICAgICAgICAgbmFtZSA9ICdmbG9hdCc7XG4gICAgICAgICAgICBwb3MgKz0gMSArIGZyYWNMZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSAnZScgfHwgc3RyW3Bvc10gPT09ICdFJykge1xuICAgICAgICAgIG5hbWUgPSAnc2NpJztcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICcrJyB8fCBzdHJbcG9zXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgaWYgKCFleHBMZW4pIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAge25hbWUsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAge25hbWU6IG5hbWUgKyAnX2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICBdO1xuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBwb3MgKz0gaWRlbnRMZW47XG4gICAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICBjYXNlICcoJzoge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICAgICAge25hbWU6ICd0aGlzX2F0dHInLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgICAgICB7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICAgICAge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICB9XG5cbiAgbGV0IGxoc0xldmVsID0gMTI7XG4gIGxldCB0cmF2O1xuXG4gIGxvb3A6IHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IGlubmVyUG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoaW5uZXJQb3MgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyk7XG4gICAgaWYgKHRyYXYudHlwZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAndHJhdmVyc2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgIHdoaWxlICh0cmF2LnR5cGUgPT09ICdzdWNjZXNzJykge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKTtcbiAgICAgICAgcG9zID0gdHJhdi5wb3NpdGlvbjtcbiAgICAgICAgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgc2tpcFdTKHN0ciwgcG9zKSk7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndHJhdmVyc2FsX2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgbGV0IHRva2VuID0gc3RyW2lubmVyUG9zXTtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlICc9Jzoge1xuICAgICAgICBsZXQgbmV4dFRva2VuID0gc3RyW2lubmVyUG9zICsgMV07XG4gICAgICAgIHN3aXRjaCAobmV4dFRva2VuKSB7XG4gICAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIC8vID0+XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BBSVIgfHwgbGhzTGV2ZWwgPD0gUFJFQ19QQUlSKSBicmVhayBsb29wXG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QQUlSKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdwYWlyJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUEFJUjtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJz0nOiB7XG4gICAgICAgICAgICAvLyA9PVxuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDUpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29wJywgcG9zaXRpb246IGlubmVyUG9zfSwge25hbWU6ICdvcF9lbmQnLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyfSk7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICcrJzoge1xuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKSBicmVhayBsb29wXG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ2FkZCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICctJzoge1xuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKSBicmVhayBsb29wXG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ3N1YicsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICcqJzoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09ICcqJykge1xuICAgICAgICAgIC8vICoqXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19QT1cgfHwgbGhzTGV2ZWwgPD0gUFJFQ19QT1cpIGJyZWFrIGxvb3BcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ3BvdycsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUE9XO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyAqXG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTVVMIHx8IGxoc0xldmVsIDwgUFJFQ19NVUwpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTVVMICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnbXVsJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01VTDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJy8nOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfRElWIHx8IGxoc0xldmVsIDwgUFJFQ19ESVYpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfRElWICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnZGl2JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0RJVjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyUnOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTU9EIHx8IGxoc0xldmVsIDwgUFJFQ19NT0QpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTU9EICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnbW9kJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01PRDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgaWYgKHN0cltuZXh0UG9zXSA9PT0gJz0nKSB7XG4gICAgICAgICAgbmV4dFBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBuZXh0UG9zfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICd8Jzoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09ICd8Jykge1xuICAgICAgICAgIC8vIHx8XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1IpIGJyZWFrIGxvb3BcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19PUiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ29yJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiAxMSB8fCBsaHNMZXZlbCA8IDExKSBicmVhayBsb29wXG4gICAgICAgICAgLy8gcGlwZSBjYWxsXG4gICAgICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKTtcbiAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICBpZiAoIWlkZW50TGVuKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBpZGVudFBvc31cbiAgICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJygnIHx8IHN0cltwb3NdID09PSAnOicpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAncGlwZWNhbGwnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICcmJzoge1xuICAgICAgICAvLyAmJlxuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gJyYnKSBicmVhayBsb29wXG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQU5EICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnYW5kJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FORDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyEnOiB7XG4gICAgICAgIC8vICE9XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gJz0nKSBicmVhayBsb29wXG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDJ9KTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2QnOiB7XG4gICAgICAgIC8vIGFzY1xuICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDQpICE9PSAnZGVzYycpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpIGJyZWFrIGxvb3BcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ2Rlc2MnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gaW5uZXJQb3MgKyA0O1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdhJzoge1xuICAgICAgICAvLyBhc2NcbiAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gJ2FzYycpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpIGJyZWFrIGxvb3BcbiAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ2FzYycsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSBpbm5lclBvcyArIDM7XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19PUkRFUjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbGV0IGlkZW50ID0gcGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCk7XG4gICAgICAgIHN3aXRjaCAoaWRlbnQpIHtcbiAgICAgICAgICBjYXNlICdpbic6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApIGJyZWFrIGxvb3BcblxuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcblxuICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgaXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICcuJyAmJiBzdHJbcG9zICsgMV0gPT09ICcuJykge1xuICAgICAgICAgICAgICAvLyBMSFMgaW4gUkFOR0VcbiAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaW5jX3JhbmdlJztcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdleGNfcmFuZ2UnO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnaW5fcmFuZ2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoe25hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvc30sIHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTEhTIGluIFJIU1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDJ9KTtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnKScpIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbWF0Y2gnOiB7XG4gICAgICAgICAgICAvLyBtYXRjaCBvcGVyYXRvclxuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnY29tcCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29wJywgcG9zaXRpb246IGlubmVyUG9zfSwge25hbWU6ICdvcF9lbmQnLCBwb3NpdGlvbjogaW5uZXJQb3MgKyA1fSk7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBmYWlsUG9zaXRpb24gPSB0cmF2Py50eXBlID09PSAnZXJyb3InICYmIHRyYXYucG9zaXRpb247XG5cbiAgcmV0dXJuIHt0eXBlOiAnc3VjY2VzcycsIG1hcmtzLCBwb3NpdGlvbjogcG9zLCBmYWlsUG9zaXRpb259XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhdmVyc2FsKHN0ciwgcG9zKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgIGNhc2UgJy4nOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKCFpZGVudExlbikgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgcG9zICs9IGlkZW50TGVuO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAge25hbWU6ICdhdHRyX2FjY2VzcycsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBpZGVudFN0YXJ0fSxcbiAgICAgICAgICB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICBdLFxuICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgfVxuICAgIH1cbiAgICBjYXNlICctJzpcbiAgICAgIGlmIChzdHJbcG9zICsgMV0gIT09ICc+JykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgLy8gLT5cblxuICAgICAgbGV0IG1hcmtzID0gW3tuYW1lOiAnZGVyZWYnLCBwb3NpdGlvbjogc3RhcnRQb3N9XTtcbiAgICAgIHBvcyArPSAyO1xuXG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MucHVzaChcbiAgICAgICAgICB7bmFtZTogJ2RlcmVmX2F0dHInLCBwb3NpdGlvbjogaWRlbnRQb3N9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogaWRlbnRQb3N9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICBtYXJrcyxcbiAgICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgIH1cbiAgICBjYXNlICdbJzoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG5cbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gJ10nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgIG1hcmtzOiBbe25hbWU6ICdhcnJheV9wb3N0Zml4JywgcG9zaXRpb246IHN0YXJ0UG9zfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDEsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHJhbmdlUG9zID0gcG9zO1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcblxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcblxuICAgICAgaWYgKHN0cltwb3NdID09PSAnLicgJiYgc3RyW3BvcyArIDFdID09PSAnLicpIHtcbiAgICAgICAgbGV0IHR5cGUgPSAnaW5jX3JhbmdlJztcbiAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgdHlwZSA9ICdleGNfcmFuZ2UnO1xuICAgICAgICAgIHBvcyArPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICBpZiAoc3RyW3Bvc10gIT09ICddJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3NsaWNlJywgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICAgIHtuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3N9LFxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyW3Bvc10gIT09ICddJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgIG1hcmtzOiBbe25hbWU6ICdzcXVhcmVfYnJhY2tldCcsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMSxcbiAgICAgIH1cbiAgICB9XG4gICAgY2FzZSAnfCc6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSAneycpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHtuYW1lOiAncHJvamVjdGlvbicsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICd7Jzoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoe25hbWU6ICdwcm9qZWN0aW9uJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxufVxuXG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xuICBsZXQgbWFya3MgPSBbXTtcblxuICBtYXJrcy5wdXNoKHtuYW1lOiAnZnVuY19jYWxsJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG5cbiAgaWYgKHN0cltwb3NdID09PSAnOicgJiYgc3RyW3BvcyArIDFdID09PSAnOicpIHtcbiAgICBtYXJrcy5wdXNoKHtuYW1lOiAnbmFtZXNwYWNlJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgbWFya3MucHVzaCh7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSwge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgbWFya3MucHVzaCh7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHBvc30sIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvcyArIG5hbWVMZW59KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09ICcoJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIG1hcmtzLnB1c2goe25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBzdGFydFBvc30sIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG5cbiAgbGV0IGxhc3RQb3MgPSBwb3M7XG5cbiAgaWYgKHN0cltwb3NdICE9PSAnKScpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICBsYXN0UG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAvLyBBbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hc1xuICAgICAgaWYgKHN0cltwb3NdID09PSAnKScpIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cltwb3NdICE9PSAnKScpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cblxuICAvLyBOT1RFOiBhIGJpdCBhcmJpdHJhcnkgdGhlIGZ1bmNfYXJnc19lbmQgcG9pbnRzIGNvbWVzIGJlZm9yZSB0aGUgd2hpdGVzcGFjZS5cbiAgbWFya3MucHVzaCh7bmFtZTogJ2Z1bmNfYXJnc19lbmQnLCBwb3NpdGlvbjogbGFzdFBvc30pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxLFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7bmFtZTogJ29iamVjdCcsIHBvc2l0aW9uOiBwb3N9XTtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG5cbiAgd2hpbGUgKHN0cltwb3NdICE9PSAnfScpIHtcbiAgICBsZXQgcGFpclBvcyA9IHBvcztcblxuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gJy4uLicpIHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSAnfScgJiYgc3RyW3Bvc10gIT09ICcsJykge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiBleHByXG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3Rfc3BsYXQnLCBwb3NpdGlvbjogcGFpclBvc30pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3Rfc3BsYXRfdGhpcycsIHBvc2l0aW9uOiBwYWlyUG9zfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChleHByLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiBleHByXG4gICAgICBsZXQgbmV4dFBvcyA9IHNraXBXUyhzdHIsIGV4cHIucG9zaXRpb24pO1xuICAgICAgaWYgKGV4cHIubWFya3NbMF0ubmFtZSA9PT0gJ3N0cicgJiYgc3RyW25leHRQb3NdID09PSAnOicpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiB2YWx1ZVxuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb2JqZWN0X3BhaXInLCBwb3NpdGlvbjogcGFpclBvc30pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzLCB2YWx1ZS5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHZhbHVlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoe25hbWU6ICdvYmplY3RfZXhwcicsIHBvc2l0aW9uOiBwb3N9LCBleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09ICcsJykgYnJlYWtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuXG4gIGlmIChzdHJbcG9zXSAhPT0gJ30nKSB7XG4gICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICB9XG5cbiAgcG9zKys7XG4gIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3RfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICByZXR1cm4ge3R5cGU6ICdzdWNjZXNzJywgbWFya3MsIHBvc2l0aW9uOiBwb3N9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0ciwgcG9zKSB7XG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xuICBwb3MgPSBwb3MgKyAxO1xuICBjb25zdCBtYXJrcyA9IFt7bmFtZTogJ3N0cicsIHBvc2l0aW9uOiBwb3N9XTtcbiAgc3RyOiBmb3IgKDsgOyBwb3MrKykge1xuICAgIGlmIChwb3MgPiBzdHIubGVuZ3RoKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG5cbiAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICBjYXNlIHRva2VuOiB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzdHJfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICBwb3MrKztcbiAgICAgICAgYnJlYWsgc3RyXG4gICAgICB9XG4gICAgICBjYXNlICdcXFxcJzoge1xuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnc3RyX3BhdXNlJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICBpZiAoc3RyW3BvcyArIDFdID09PSAndScpIHtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSAneycpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICd1bmljb2RlX2hleCcsIHBvc2l0aW9uOiBwb3MgKyAzfSk7XG4gICAgICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZignfScsIHBvcyArIDMpO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4X2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4JywgcG9zaXRpb246IHBvcyArIDJ9KTtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICd1bmljb2RlX2hleF9lbmQnLCBwb3NpdGlvbjogcG9zICsgNn0pO1xuICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzaW5nbGVfZXNjYXBlJywgcG9zaXRpb246IHBvcyArIDF9KTtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnc3RyX3N0YXJ0JywgcG9zaXRpb246IHBvcyArIDF9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3R5cGU6ICdzdWNjZXNzJywgbWFya3MsIHBvc2l0aW9uOiBwb3N9XG59XG5cbmZ1bmN0aW9uIHNraXBXUyhzdHIsIHBvcykge1xuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpXG59XG5cbi8qKlxuICogUGFyc2VzIGEgcmVnZXggYXQgYSBwb3NpdGlvbiBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3YXMgbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VSZWdleChzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDBcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSByZWdleCBhdCBhIHBvc2l0aW9uIGFuZCByZXR1cm5zIG1hdGNoZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsXG59LyoqXG4gKiBKb2luIGNvbWJpbmVzIHR3byB0cmF2ZXJzYWxzLCByZXR1cm5pbmcgYSBtYXBwZXIgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBmaXJzdFxuICogYXBwbHlpbmcgYGFgIGFuZCB0aGVuIGFwcGx5aW5nIGBiYC5cbiAqL1xuZnVuY3Rpb24gam9pbihhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiBiKGEoYmFzZSkpOyB9O1xufVxuLyoqXG4gKiBNYXAgcmV0dXJucyBhIG5ldyBtYXBwZXIgd2hpY2ggd2lsbCB0aGUgaW5uZXIgbWFwcGUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gbWFwKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnTWFwJywgYmFzZTogYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiAnVGhpcycgfSkgfSk7IH07XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnRmxhdE1hcCcsIGJhc2U6IGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogJ1RoaXMnIH0pIH0pOyB9O1xufVxuZnVuY3Rpb24gdHJhdmVyc2VBcnJheShidWlsZCwgcmlnaHQpIHtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgIGJ1aWxkOiBidWlsZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYS1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYi1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUGxhaW4obWFwcGVyLCByaWdodCkge1xuICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgYnVpbGQ6IG1hcHBlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYS1hJzpcbiAgICAgICAgY2FzZSAnYi1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ItYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2EtYic6XG4gICAgICAgIGNhc2UgJ2ItYic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlRWxlbWVudChtYXBwZXIsIHJpZ2h0KSB7XG4gICAgaWYgKCFyaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICBidWlsZDogbWFwcGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgICAgICBjYXNlICdhLWEnOlxuICAgICAgICBjYXNlICdiLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgY2FzZSAnYi1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYi1iJyxcbiAgICAgICAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2EtYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2EtYic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWInLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ItYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYi1iJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgICB9XG59dmFyIGlzRXF1YWwgPSBlcXVhbGl0eTtcbmZ1bmN0aW9uIGVxdWFsaXR5KGEsIGIpIHtcbiAgICBpZiAoKGEudHlwZSA9PT0gJ3N0cmluZycgJiYgYi50eXBlID09PSAnc3RyaW5nJykgfHxcbiAgICAgICAgKGEudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGIudHlwZSA9PT0gJ2Jvb2xlYW4nKSB8fFxuICAgICAgICAoYS50eXBlID09PSAnbnVsbCcgJiYgYi50eXBlID09PSAnbnVsbCcpIHx8XG4gICAgICAgIChhLnR5cGUgPT09ICdudW1iZXInICYmIGIudHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHJldHVybiBhLmRhdGEgPT09IGIuZGF0YTtcbiAgICB9XG4gICAgaWYgKGEudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiBiLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgcmV0dXJuIGEuZGF0YS5lcXVhbHMoYi5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufXZhciBvcGVyYXRvcnMgPSB7XG4gICAgJz09JzogZnVuY3Rpb24gZXEobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgJyE9JzogZnVuY3Rpb24gbmVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgICB9LFxuICAgICc+JzogZnVuY3Rpb24gZ3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ3N0cmVhbScgfHwgcmlnaHQudHlwZSA9PT0gJ3N0cmVhbScpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgJz49JzogZnVuY3Rpb24gZ3RlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJlYW0nIHx8IHJpZ2h0LnR5cGUgPT09ICdzdHJlYW0nKVxuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAnPCc6IGZ1bmN0aW9uIGx0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJlYW0nIHx8IHJpZ2h0LnR5cGUgPT09ICdzdHJlYW0nKVxuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9LFxuICAgICc8PSc6IGZ1bmN0aW9uIGx0ZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnc3RyZWFtJyB8fCByaWdodC50eXBlID09PSAnc3RyZWFtJylcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgIFwiaW5cIjogZnVuY3Rpb24gaW5vcChsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgcmlnaHRfMSwgcmlnaHRfMV8xO1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGIsIGVfMV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJpZ2h0LmRhdGEubWF0Y2hlcyhsZWZ0LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmlnaHQuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgNiwgNywgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0XzEgPSBfX2FzeW5jVmFsdWVzKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCByaWdodF8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJpZ2h0XzFfMSA9IF9iLnNlbnQoKSwgIXJpZ2h0XzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gcmlnaHRfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgVFJVRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbNywgLCAxMCwgMTFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJpZ2h0XzFfMSAmJiAhcmlnaHRfMV8xLmRvbmUgJiYgKF9hID0gcmlnaHRfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwocmlnaHRfMSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5zLCBwYXR0ZXJucywgZGlkU3VjY2VlZCwgbWF0Y2hlZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdhdGhlclRleHQobGVmdCwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdhdGhlclRleHQocmlnaHQsIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU3VjY2VlZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG1hdGNoZWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgICcrJzogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnZGF0ZXRpbWUnICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdudW1iZXInICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEgKyByaWdodC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnc3RyaW5nJyAmJiByaWdodC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ29iamVjdCcgJiYgcmlnaHQudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSlMoX19hc3NpZ24oX19hc3NpZ24oe30sIGxlZnQuZGF0YSksIHJpZ2h0LmRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnYXJyYXknICYmIHJpZ2h0LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0XzEsIGxlZnRfMV8xLCB2YWwsIGVfMl8xLCByaWdodF8yLCByaWdodF8yXzEsIHZhbCwgZV8zXzE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlXzIsIF9hLCBlXzMsIF9iO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRfMSA9IF9fYXN5bmNWYWx1ZXMobGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQobGVmdF8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobGVmdF8xXzEgPSBfYy5zZW50KCksICFsZWZ0XzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGxlZnRfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShsZWZ0XzFfMSAmJiAhbGVmdF8xXzEuZG9uZSAmJiAoX2EgPSBsZWZ0XzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9hLmNhbGwobGVmdF8xKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEzLCAyMCwgMjEsIDI2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0XzIgPSBfX2FzeW5jVmFsdWVzKHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHJpZ2h0XzIubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMl8xID0gX2Muc2VudCgpLCAhcmlnaHRfMl8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJpZ2h0XzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWwpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMjZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfM18xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzMgPSB7IGVycm9yOiBlXzNfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsyMSwgLCAyNCwgMjVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMl8xICYmICFyaWdodF8yXzEuZG9uZSAmJiAoX2IgPSByaWdodF8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDIzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYi5jYWxsKHJpZ2h0XzIpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfSxcbiAgICAnLSc6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdkYXRldGltZScgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdkYXRldGltZScgJiYgcmlnaHQudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdudW1iZXInICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEgLSByaWdodC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgICcqJzogbnVtZXJpY09wZXJhdG9yKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICogYjsgfSksXG4gICAgJy8nOiBudW1lcmljT3BlcmF0b3IoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLyBiOyB9KSxcbiAgICAnJSc6IG51bWVyaWNPcGVyYXRvcihmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAlIGI7IH0pLFxuICAgICcqKic6IG51bWVyaWNPcGVyYXRvcihmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5wb3coYSwgYik7IH0pXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdudW1iZXInICYmIHJpZ2h0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9O1xufXZhciBTY29wZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIGZ1bmN0aW9uIFNjb3BlKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBTY29wZS5wcm90b3R5cGUuY3JlYXRlTmVzdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzKTtcbiAgICB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS5jcmVhdGVIaWRkZW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0LmlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTY29wZTtcbn0oKSk7ZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBpZiAoZXhlY3V0ZSA9PT0gdm9pZCAwKSB7IGV4ZWN1dGUgPSBldmFsdWF0ZTsgfVxuICAgIHZhciBmdW5jID0gRVhFQ1VUT1JTW25vZGUudHlwZV07XG4gICAgcmV0dXJuIGZ1bmMobm9kZSwgc2NvcGUsIGV4ZWN1dGUpO1xufVxuLyoqXG4gKiBBcHBsaWVzIHRoZSBmdW5jdGlvbiB0byBhIHZhbHVlLCBidXQgdHJpZXMgdG8gYXZvaWQgY3JlYXRpbmcgdW5uZWNlc3NhcnkgcHJvbWlzZXMuXG4gKi9cbmZ1bmN0aW9uIHByb21pc2VsZXNzQXBwbHkodmFsdWUsIGNiKSB7XG4gICAgaWYgKCd0aGVuJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudGhlbihjYik7XG4gICAgfVxuICAgIHJldHVybiBjYih2YWx1ZSk7XG59XG52YXIgRVhFQ1VUT1JTID0ge1xuICAgIFRoaXM6IGZ1bmN0aW9uIChfLCBzY29wZSkge1xuICAgICAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gICAgfSxcbiAgICBTZWxlY3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGVzZSBzaG91bGQgYmUgZXZhbHVhdGVkIHNlcGFyZWx5IHVzaW5nIGEgZGlmZmVyZW50IGV2YWx1YXRvci5cbiAgICAgICAgLy8gQXQgdGhlIG1vb21lbnQgd2UgaGF2ZW4ndCBpbXBsZW1lbnRlZCB0aGlzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbGVjdG9ycyBjYW4gbm90IGJlIGV2YWx1YXRlZCcpO1xuICAgIH0sXG4gICAgRXZlcnl0aGluZzogZnVuY3Rpb24gKF8sIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzY29wZS5zb3VyY2U7XG4gICAgfSxcbiAgICBQYXJhbWV0ZXI6IGZ1bmN0aW9uIChfYSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICByZXR1cm4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSk7XG4gICAgfSxcbiAgICBDb250ZXh0OiBmdW5jdGlvbiAoX2EsIHNjb3BlKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYS5rZXk7XG4gICAgICAgIGlmIChrZXkgPT09ICdiZWZvcmUnIHx8IGtleSA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGUuY29udGV4dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IE5VTExfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBjb250ZXh0IGtleTogXCIuY29uY2F0KGtleSkpO1xuICAgIH0sXG4gICAgUGFyZW50OiBmdW5jdGlvbiAoX2EsIHNjb3BlKSB7XG4gICAgICAgIHZhciBuID0gX2EubjtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBzY29wZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICB9LFxuICAgIE9wQ2FsbDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3AgPSBfYS5vcCwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgIHZhciBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yOiBcIi5jb25jYXQob3ApKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgICAgIHZhciByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgICAgICAvLyBBdm9pZCB1bmVjY2VzYXJ5IHByb21pc2VzXG4gICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGNvbnN0YW50IGV2YWx1YXRpb24gdG8gd29yayBjb3JyZWN0bHkuXG4gICAgICAgIGlmICgndGhlbicgaW4gbGVmdFZhbHVlIHx8ICd0aGVuJyBpbiByaWdodFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgdmFyIF9hLCBfYjsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBmdW5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGVmdFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBbX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJpZ2h0VmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5hcHBseSh2b2lkIDAsIF9iLmNvbmNhdChbX2Muc2VudCgpXSkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgfSk7IH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICB9LFxuICAgIFNlbGVjdDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmVzID0gX2EuYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayA9IF9hLmZhbGxiYWNrO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2ksIGFsdGVybmF0aXZlc18xLCBhbHQsIGFsdENvbmQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSA9IDAsIGFsdGVybmF0aXZlc18xID0gYWx0ZXJuYXRpdmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGFsdGVybmF0aXZlc18xLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ID0gYWx0ZXJuYXRpdmVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRDb25kID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsdENvbmQudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGFsdENvbmQuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleGVjdXRlKGFsdC52YWx1ZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXhlY3V0ZShmYWxsYmFjaywgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBJblJhbmdlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQsIGlzSW5jbHVzaXZlID0gX2EuaXNJbmNsdXNpdmU7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgbGVmdFZhbHVlLCByaWdodFZhbHVlLCBsZWZ0Q21wLCBfYiwgX2MsIHJpZ2h0Q21wLCBfZCwgX2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGxlZnQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRWYWx1ZSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUocmlnaHQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHBhcnRpYWxDb21wYXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IFtfZi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGVmdFZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdENtcCA9IF9iLmFwcGx5KHZvaWQgMCwgX2MuY29uY2F0KFtfZi5zZW50KCldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdENtcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gcGFydGlhbENvbXBhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gW19mLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByaWdodFZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRDbXAgPSBfZC5hcHBseSh2b2lkIDAsIF9lLmNvbmNhdChbX2Yuc2VudCgpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBGaWx0ZXI6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBleHByID0gX2EuZXhwcjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVZhbHVlXzEsIGJhc2VWYWx1ZV8xXzEsIGVsZW0sIG5ld1Njb3BlLCBleHByVmFsdWUsIGVfMV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzAsIDgsIDksIDE0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWVfMSA9IF9fYXN5bmNWYWx1ZXMoYmFzZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGJhc2VWYWx1ZV8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlVmFsdWVfMV8xID0gX2Iuc2VudCgpLCAhYmFzZVZhbHVlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gYmFzZVZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChleGVjdXRlKGV4cHIsIG5ld1Njb3BlKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShleHByVmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIGV4cHJWYWx1ZS5kYXRhID09PSB0cnVlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGVsZW0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOSwgLCAxMiwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJhc2VWYWx1ZV8xXzEgJiYgIWJhc2VWYWx1ZV8xXzEuZG9uZSAmJiAoX2EgPSBiYXNlVmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9hLmNhbGwoYmFzZVZhbHVlXzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBQcm9qZWN0aW9uOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgZXhwciA9IF9hLmV4cHI7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlVmFsdWUsIG5ld1Njb3BlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBGdW5jQ2FsbDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IF9hLmZ1bmMsIGFyZ3MgPSBfYS5hcmdzO1xuICAgICAgICByZXR1cm4gZnVuYyhhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgfSxcbiAgICBQaXBlRnVuY0NhbGw6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBfYS5mdW5jLCBiYXNlID0gX2EuYmFzZSwgYXJncyA9IF9hLmFyZ3M7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZ1bmMoYmFzZVZhbHVlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEFjY2Vzc0F0dHJpYnV0ZTogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2UsIG5hbWUgPSBfYS5uYW1lO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNjb3BlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5kYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlModmFsdWUuZGF0YVtuYW1lXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBY2Nlc3NFbGVtZW50OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgaW5kZXggPSBfYS5pbmRleDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSwgZGF0YSwgZmluYWxJbmRleDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBiYXNlVmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFNsaWNlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQsIGlzSW5jbHVzaXZlID0gX2EuaXNJbmNsdXNpdmU7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlVmFsdWUsIGFycmF5LCBsZWZ0SWR4LCByaWdodElkeDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBiYXNlVmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheSA9IChfYi5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdElkeCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodElkeCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SWR4ID0gYXJyYXkubGVuZ3RoICsgbGVmdElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodElkeCA9IGFycmF5Lmxlbmd0aCArIHJpZ2h0SWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIGluY2x1c2l2ZSB0byBleGNsdXNpdmUgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodElkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBBdCB0aGlzIHBvaW50IHRoZSBpbmRpY2VzIG1pZ2h0IHBvaW50IG91dC1vZi1ib3VuZCwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuc2xpY2UgaGFuZGxlcyB0aGlzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tSlMoYXJyYXkuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgRGVyZWY6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGVfMiwgX2I7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBpZCwgX2MsIF9kLCBkb2MsIGVfMl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5kYXRhLl9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2UudHJ5cy5wdXNoKFsyLCA3LCA4LCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBfX2FzeW5jVmFsdWVzKHNjb3BlLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2MubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2QgPSBfZS5zZW50KCksICFfZC5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2MudHlwZSA9PT0gJ29iamVjdCcgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkb2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yXzEgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZCAmJiAhX2QuZG9uZSAmJiAoX2IgPSBfY1tcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5jYWxsKF9jKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBWYWx1ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgICB9LFxuICAgIEdyb3VwOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIH0sXG4gICAgT2JqZWN0OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gX2EuYXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2ksIGF0dHJpYnV0ZXNfMSwgYXR0ciwgYXR0clR5cGUsIF9iLCB2YWx1ZSwgX2MsIF9kLCBjb25kLCB2YWx1ZSwgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYXR0cmlidXRlc18xID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBhdHRyaWJ1dGVzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gYXR0ci50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ09iamVjdEF0dHJpYnV0ZVZhbHVlJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT2JqZWN0Q29uZGl0aW9uYWxTcGxhdCc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ09iamVjdFNwbGF0JzogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jW19kXSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gJ2Jvb2xlYW4nIHx8IGNvbmQuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIi5jb25jYXQoYXR0clR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBcnJheTogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBfYS5lbGVtZW50cztcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2ksIGVsZW1lbnRzXzEsIGVsZW1lbnQsIHZhbHVlLCB2YWx1ZV8xLCB2YWx1ZV8xXzEsIHYsIGVfM18xO1xuICAgICAgICAgICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgZWxlbWVudHNfMSA9IGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGVsZW1lbnRzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZWxlbWVudC52YWx1ZSwgc2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmlzU3BsYXQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzMsIDEwLCAxMSwgMTZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV8xID0gKGVfMyA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWx1ZV8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSA9IF9iLnNlbnQoKSwgIXZhbHVlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHYpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzNfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzMgPSB7IGVycm9yOiBlXzNfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxMSwgLCAxNCwgMTVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8xXzEgJiYgIXZhbHVlXzFfMS5kb25lICYmIChfYSA9IHZhbHVlXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWx1ZV8xKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMjBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxODogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFR1cGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkJyk7XG4gICAgfSxcbiAgICBPcjogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobGVmdCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShyaWdodCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09ICdib29sZWFuJyB8fCByaWdodFZhbHVlLnR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgQW5kOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShsZWZ0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKHJpZ2h0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodFZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09ICdib29sZWFuJyB8fCByaWdodFZhbHVlLnR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBOb3Q6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIE5lZzogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2U7XG4gICAgICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFBvczogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2U7XG4gICAgICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgQXNjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgRGVzYzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgIEFycmF5Q29lcmNlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgTWFwOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgZXhwciA9IF9hLmV4cHI7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzIsIHZhbHVlXzJfMSwgZWxlbSwgbmV3U2NvcGUsIGVfNF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzAsIDgsIDksIDE0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV8yID0gX19hc3luY1ZhbHVlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdCh2YWx1ZV8yLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8yXzEgPSBfYi5zZW50KCksICF2YWx1ZV8yXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHZhbHVlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChleGVjdXRlKGV4cHIsIG5ld1Njb3BlKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNF8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV80ID0geyBlcnJvcjogZV80XzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs5LCAsIDEyLCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMl8xICYmICF2YWx1ZV8yXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8yW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWx1ZV8yKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgRmxhdE1hcDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2UsIGV4cHIgPSBfYS5leHByO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgU3RyZWFtVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8zLCB2YWx1ZV8zXzEsIGVsZW0sIG5ld1Njb3BlLCBpbm5lclZhbHVlLCBpbm5lclZhbHVlXzEsIGlubmVyVmFsdWVfMV8xLCBpbm5lciwgZV81XzEsIGVfNl8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfNiwgX2EsIGVfNSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDIzLCAyNCwgMjldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXzMgPSBfX2FzeW5jVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlXzMubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzNfMSA9IF9jLnNlbnQoKSwgIXZhbHVlXzNfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHZhbHVlXzNfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChleGVjdXRlKGV4cHIsIG5ld1Njb3BlKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclZhbHVlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbm5lclZhbHVlLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzQsIDExLCAxMiwgMTddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsdWVfMSA9IChlXzUgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMoaW5uZXJWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoaW5uZXJWYWx1ZV8xLm5leHQoKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lclZhbHVlXzFfMSA9IF9jLnNlbnQoKSwgIWlubmVyVmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lciA9IGlubmVyVmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChpbm5lcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV81XzEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzUgPSB7IGVycm9yOiBlXzVfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxMiwgLCAxNSwgMTZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyVmFsdWVfMV8xICYmICFpbm5lclZhbHVlXzFfMS5kb25lICYmIChfYiA9IGlubmVyVmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9iLmNhbGwoaW5uZXJWYWx1ZV8xKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGlubmVyVmFsdWUpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOiByZXR1cm4gWzMgLypicmVhayovLCAyOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzZfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNiA9IHsgZXJyb3I6IGVfNl8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzI0LCAsIDI3LCAyOF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfM18xICYmICF2YWx1ZV8zXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8zW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDI2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWx1ZV8zKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMjhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyODogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKipcbiAqIEV2YWx1YXRlcyBhIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHRyZWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByb290ID0gZnJvbUpTKG9wdGlvbnMucm9vdCk7XG4gICAgdmFyIGRhdGFzZXQgPSBmcm9tSlMob3B0aW9ucy5kYXRhc2V0KTtcbiAgICB2YXIgcGFyYW1zID0gX19hc3NpZ24oe30sIG9wdGlvbnMucGFyYW1zKTtcbiAgICB2YXIgc2NvcGUgPSBuZXcgU2NvcGUocGFyYW1zLCBkYXRhc2V0LCByb290LCB7XG4gICAgICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAgfHwgbmV3IERhdGUoKSxcbiAgICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHVuZGVmaW5lZCA/ICdtZScgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgICBhZnRlcjogb3B0aW9ucy5hZnRlciA/IGZyb21KUyhvcHRpb25zLmFmdGVyKSA6IG51bGwsXG4gICAgICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbFxuICAgIH0sIG51bGwpO1xuICAgIHJldHVybiBldmFsdWF0ZSh0cmVlLCBzY29wZSk7XG59ZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnR3JvdXAnOlxuICAgICAgICBjYXNlICdWYWx1ZSc6XG4gICAgICAgIGNhc2UgJ1BhcmFtZXRlcic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnUG9zJzpcbiAgICAgICAgY2FzZSAnTmVnJzpcbiAgICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgICAgIGNhc2UgJ09wQ2FsbCc6XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBjYXNlICcqKic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlKHt9LCBOVUxMX1ZBTFVFLCBOVUxMX1ZBTFVFLCB7IHRpbWVzdGFtcDogbmV3IERhdGUoMCksIGlkZW50aXR5OiAnbWUnLCBiZWZvcmU6IG51bGwsIGFmdGVyOiBudWxsIH0sIG51bGwpO1xuZnVuY3Rpb24gdHJ5Q29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gICAgaWYgKCFjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RhbnRFdmFsdWF0ZShub2RlKTtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IGV2YWx1YXRlKG5vZGUsIERVTU1ZX1NDT1BFLCBjb25zdGFudEV2YWx1YXRlKTtcbiAgICBpZiAoJ3RoZW4nIGluIHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59dmFyIEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1wiJzogJ1wiJyxcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAnLyc6ICcvJyxcbiAgICBiOiAnXFxiJyxcbiAgICBmOiAnXFxmJyxcbiAgICBuOiAnXFxuJyxcbiAgICByOiAnXFxyJyxcbiAgICB0OiAnXFx0J1xufTtcbmZ1bmN0aW9uIGV4cGFuZEhleChzdHIpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG52YXIgR3JvcVF1ZXJ5RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3FRdWVyeUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3FRdWVyeUVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdHcm9xUXVlcnlFcnJvcic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdyb3FRdWVyeUVycm9yO1xufShFcnJvcikpO1xudmFyIEVYUFJfQlVJTERFUiA9IHtcbiAgICBncm91cDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGlubmVyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnR3JvdXAnLFxuICAgICAgICAgICAgYmFzZTogaW5uZXJcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGV2ZXJ5dGhpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0V2ZXJ5dGhpbmcnIH07XG4gICAgfSxcbiAgICBcInRoaXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnVGhpcycgfTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BhcmVudCcsXG4gICAgICAgICAgICBuOiAxXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkYmxwYXJlbnQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGFyZW50JyxcbiAgICAgICAgICAgIG46IG5leHQubiArIDFcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ3RyYXZlcnNhbF9lbmQnKSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHZhciB0cmF2ZXJzYWwgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlLnR5cGUgPT09ICdFdmVyeXRoaW5nJyB8fCBiYXNlLnR5cGUgPT09ICdBcnJheScgfHwgYmFzZS50eXBlID09PSAnUGlwZUZ1bmNDYWxsJykge1xuICAgICAgICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWw7IH0sIHRyYXZlcnNhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYXZlcnNhbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbCcpO1xuICAgICAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICAgIH0sXG4gICAgdGhpc19hdHRyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnVmFsdWUnLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG5lZzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdOZWcnLFxuICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcG9zOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BvcycsXG4gICAgICAgICAgICBiYXNlOiBiYXNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJysnLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3ViOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICctJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG11bDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnKicsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkaXY6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJy8nLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbW9kOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICclJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBvdzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnKionLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIG9wID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogb3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpbl9yYW5nZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gJ2luY19yYW5nZSc7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnSW5SYW5nZScsXG4gICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgIGlzSW5jbHVzaXZlOiBpc0luY2x1c2l2ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3RyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICBsb29wOiB3aGlsZSAocC5oYXNNYXJrKCkpIHtcbiAgICAgICAgICAgIHZhciBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cl9lbmQnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cl9wYXVzZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJfc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZV9lc2NhcGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gcC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd1bmljb2RlX2hleCc6XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBtYXJrOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IHZhbHVlIH07XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdWYWx1ZScsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZmxvYXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzY2k6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAnb2JqZWN0X2VuZCcpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0JyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFycmF5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICdhcnJheV9lbmQnKSB7XG4gICAgICAgICAgICB2YXIgaXNTcGxhdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdhcnJheV9zcGxhdCcpIHtcbiAgICAgICAgICAgICAgICBpc1NwbGF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdBcnJheUVsZW1lbnQnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpc1NwbGF0OiBpc1NwbGF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnQXJyYXknLFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0dXBsZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG1lbWJlcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICd0dXBsZV9lbmQnKSB7XG4gICAgICAgICAgICBtZW1iZXJzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdUdXBsZScsXG4gICAgICAgICAgICBtZW1iZXJzOiBtZW1iZXJzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBmdW5jX2NhbGw6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSAnZ2xvYmFsJztcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICduYW1lc3BhY2UnKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICBpZiAobmFtZXNwYWNlID09PSAnZ2xvYmFsJyAmJiBuYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU2VsZWN0JyxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICdmdW5jX2FyZ3NfZW5kJykge1xuICAgICAgICAgICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSAncGFpcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsdGVybmF0aXZlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTZWxlY3RBbHRlcm5hdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ2Z1bmNfYXJnc19lbmQnKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgbmFtZSwgYXJncy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIGRpZmYvZGVsdGEgZnVuY3Rpb25zIGFyZW4ndCB2YWxpZGF0ZWQgeWV0IHdlIG9ubHkgd2FudCB0byB2YWxpZGF0ZSB0aGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAvLyBiZWluZyB1c2VkLiBXZSBleHBlY3QgdGhlIG51bGwgdmFsdWVkIGFyZyB0byB0aHJvdyBhbiBlcnJvciBhdCBldmFsdWF0aW9uIHRpbWUuXG4gICAgICAgICAgICAgICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6ICdTZWxlY3RvcicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gJ2dsb2JhbCcgJiYgKG5hbWUgPT09ICdiZWZvcmUnIHx8IG5hbWUgPT09ICdhZnRlcicpKSB7XG4gICAgICAgICAgICBpZiAocC5wYXJzZU9wdGlvbnMubW9kZSA9PT0gJ2RlbHRhJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDb250ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuYW1lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlID09PSAnZ2xvYmFsJyAmJiBuYW1lID09PSAnYm9vc3QnICYmICFwLmFsbG93Qm9vc3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3VuZXhwZWN0ZWQgYm9vc3QnKTtcbiAgICAgICAgdmFyIGZ1bmNzID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VdO1xuICAgICAgICBpZiAoIWZ1bmNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgbmFtZXNwYWNlOiBcIi5jb25jYXQobmFtZXNwYWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMuYXJpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMubW9kZSAhPT0gdW5kZWZpbmVkICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnRnVuY0NhbGwnLFxuICAgICAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwaXBlY2FsbDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcC5zaGlmdCgpOyAvLyBSZW1vdmUgdGhlIGZ1bmNfY2FsbFxuICAgICAgICB2YXIgbmFtZXNwYWNlID0gJ2dsb2JhbCc7XG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSAnbmFtZXNwYWNlJykge1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBuYW1lc3BhY2U6IFwiLmNvbmNhdChuYW1lc3BhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB2YXIgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzY29yZScpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWxsb3cgYm9vc3QgaW5zaWRlIGEgc2NvcmUgZXhwcmVzc2lvblxuICAgICAgICAgICAgcC5hbGxvd0Jvb3N0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB2YXIgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1hcmtOYW1lID09PSAnZnVuY19hcmdzX2VuZCcpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb3JkZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtOYW1lID09PSAnYXNjJykge1xuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6ICdBc2MnLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcmtOYW1lID09PSAnZGVzYycpIHtcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiAnRGVzYycsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcbiAgICAgICAgdmFyIGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBwaXBlIGZ1bmN0aW9uOiBcIi5jb25jYXQobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jLmFyaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BpcGVGdW5jQ2FsbCcsXG4gICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYWlyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICAgIH0sXG4gICAgYW5kOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBbmQnLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb3I6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09yJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdOb3QnLFxuICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3VuZXhwZWN0ZWQgYXNjJyk7XG4gICAgfSxcbiAgICBkZXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3VuZXhwZWN0ZWQgZGVzYycpO1xuICAgIH0sXG4gICAgcGFyYW06IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdWYWx1ZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BhcmFtZXRlcicsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgfVxufTtcbnZhciBPQkpFQ1RfQlVJTERFUiA9IHtcbiAgICBvYmplY3RfZXhwcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdwYWlyJykge1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ09iamVjdENvbmRpdGlvbmFsU3BsYXQnLFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZV8xXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdEF0dHJpYnV0ZVZhbHVlJyxcbiAgICAgICAgICAgIG5hbWU6IGV4dHJhY3RQcm9wZXJ0eUtleSh2YWx1ZSksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9wYWlyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICBpZiAobmFtZS50eXBlICE9PSAnVmFsdWUnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdEF0dHJpYnV0ZVZhbHVlJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9zcGxhdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0U3BsYXQnLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvYmplY3Rfc3BsYXRfdGhpczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09iamVjdFNwbGF0JyxcbiAgICAgICAgICAgIHZhbHVlOiB7IHR5cGU6ICdUaGlzJyB9XG4gICAgICAgIH07XG4gICAgfVxufTtcbnZhciBUUkFWRVJTRV9CVUlMREVSID0ge1xuICAgIHNxdWFyZV9icmFja2V0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VFbGVtZW50KGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnQWNjZXNzRWxlbWVudCcsIGJhc2U6IGJhc2UsIGluZGV4OiB2YWx1ZS5kYXRhIH0pOyB9LCByaWdodCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZVBsYWluKGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJywgYmFzZTogYmFzZSwgbmFtZTogdmFsdWUuZGF0YSB9KTsgfSwgcmlnaHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRmlsdGVyJyxcbiAgICAgICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgICAgIGV4cHI6IGV4cHJcbiAgICAgICAgICAgIH0pOyB9LCByaWdodCk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzbGljZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gJ2luY19yYW5nZSc7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpO1xuICAgICAgICB2YXIgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgICAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gJ251bWJlcicgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKCdzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlQXJyYXkoZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NsaWNlJyxcbiAgICAgICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnRWYWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgaXNJbmNsdXNpdmU6IGlzSW5jbHVzaXZlXG4gICAgICAgICAgICB9KTsgfSwgcmhzKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlUHJvamVjdGlvbihmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHsgdHlwZTogJ1Byb2plY3Rpb24nLCBiYXNlOiBiYXNlLCBleHByOiBvYmogfSk7IH0sIHJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGF0dHJfYWNjZXNzOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7IHJldHVybiB0cmF2ZXJzZVBsYWluKGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJywgYmFzZTogYmFzZSwgbmFtZTogbmFtZSB9KTsgfSwgcmlnaHQpOyB9O1xuICAgIH0sXG4gICAgZGVyZWY6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBhdHRyID0gbnVsbDtcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdkZXJlZl9hdHRyJykge1xuICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgYXR0ciA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyID8geyB0eXBlOiAnQWNjZXNzQXR0cmlidXRlJywgYmFzZTogYmFzZSwgbmFtZTogYXR0ciB9IDogYmFzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlUGxhaW4oZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdEZXJlZicsXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IGJhc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFycmF5X3Bvc3RmaXg6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHsgcmV0dXJuIHRyYXZlcnNlQXJyYXkoZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBcnJheUNvZXJjZScsIGJhc2U6IGJhc2UgfSk7IH0sIHJpZ2h0KTsgfTtcbiAgICB9XG59O1xudmFyIFNFTEVDVE9SX0JVSUxERVIgPSB7XG4gICAgZ3JvdXA6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBldmVyeXRoaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIFwidGhpc1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBkYmxwYXJlbnQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAndHJhdmVyc2FsX2VuZCcpIHtcbiAgICAgICAgICAgIHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKTtcbiAgICAgICAgfVxuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgdGhpc19hdHRyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBuZWc6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBvczogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBzdWI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIG11bDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgZGl2OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBtb2Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBvdzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgY29tcDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgaW5fcmFuZ2U6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHN0cjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgZmxvYXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHNjaTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgb2JqZWN0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBhcnJheTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgdHVwbGU6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgdGhyb3cgYW4gZXJyb3IgdW50aWwgd2UgYWRkIHN1cHBvcnQgZm9yIHR1cGxlcyBpbiBzZWxlY3RvcnMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGZ1bmNfY2FsbDogZnVuY3Rpb24gKHAsIG1hcmspIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgICAgICBpZiAoZnVuYy5uYW1lID09PSAnYW55d2hlcmUnICYmIGZ1bmMuYXJncy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcGlwZWNhbGw6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBhaXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGFuZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgb3I6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgYXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBkZXNjOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBwYXJhbTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdBY2Nlc3NBdHRyaWJ1dGUnICYmICFub2RlLmJhc2UpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0RlcmVmJyB8fFxuICAgICAgICBub2RlLnR5cGUgPT09ICdNYXAnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ1Byb2plY3Rpb24nIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ1NsaWNlJyB8fFxuICAgICAgICBub2RlLnR5cGUgPT09ICdGaWx0ZXInIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ0FjY2Vzc0VsZW1lbnQnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ0FycmF5Q29lcmNlJykge1xuICAgICAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkNhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkga2V5IGZvciB0eXBlOiBcIi5jb25jYXQobm9kZS50eXBlKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGFyaXR5LCBjb3VudCkge1xuICAgIGlmICh0eXBlb2YgYXJpdHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChjb3VudCAhPT0gYXJpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLiBFeHBlY3RlZCBcIikuY29uY2F0KGFyaXR5LCBcIiwgZ290IFwiKS5jb25jYXQoY291bnQsIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXJpdHkpIHtcbiAgICAgICAgaWYgKCFhcml0eShjb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIkluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIFwiLmNvbmNhdChuYW1lLCBcIigpLlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBmdW5jdGlvbk5hbWUsIGFyZ0NvdW50KSB7XG4gICAgdmFyIGZ1bmN0aW9uc1JlcXVpcmluZ1NlbGVjdG9ycyA9IFsnY2hhbmdlZEFueScsICdjaGFuZ2VkT25seSddO1xuICAgIHJldHVybiBuYW1lc3BhY2UgPT0gJ2RpZmYnICYmIGFyZ0NvdW50ID09IDIgJiYgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzLmluY2x1ZGVzKGZ1bmN0aW9uTmFtZSk7XG59XG52YXIgR3JvcVN5bnRheEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm9xU3ludGF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvcVN5bnRheEVycm9yKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gXCIuY29uY2F0KHBvc2l0aW9uKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdHcm9xU3ludGF4RXJyb3InO1xuICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBHcm9xU3ludGF4RXJyb3I7XG59KEVycm9yKSk7XG4vKipcbiAqIFBhcnNlcyBhIEdST1EgcXVlcnkgYW5kIHJldHVybnMgYSB0cmVlIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcbiAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24pO1xuICAgIH1cbiAgICB2YXIgcHJvY2Vzc29yID0gbmV3IE1hcmtQcm9jZXNzb3IoaW5wdXQsIHJlc3VsdC5tYXJrcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHByb2Nlc3Nvci5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG59ZXhwb3J0cy5ldmFsdWF0ZT1ldmFsdWF0ZVF1ZXJ5O2V4cG9ydHMucGFyc2U9cGFyc2U7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJ19fZXNNb2R1bGUnLHt2YWx1ZTp0cnVlfSk7fSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/groq-js/dist/1.umd.cjs\n"));

/***/ }),

/***/ "./node_modules/throttle-debounce/cjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/throttle-debounce/cjs/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nfunction throttle (delay, callback, options) {\n  var _ref = options || {},\n      _ref$noTrailing = _ref.noTrailing,\n      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,\n      _ref$noLeading = _ref.noLeading,\n      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,\n      _ref$debounceMode = _ref.debounceMode,\n      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n\n\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel(options) {\n    var _ref2 = options || {},\n        _ref2$upcomingOnly = _ref2.upcomingOnly,\n        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\n\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (!noLeading && debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`\n       * and noLeading != true.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      if (noLeading) {\n        /*\n         * In throttle mode with noLeading, if `delay` time has\n         * been exceeded, update `lastExec` and schedule `callback`\n         * to execute after `delay` ms.\n         */\n        lastExec = Date.now();\n\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        /*\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n         * `callback`.\n         */\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, callback, options) {\n  var _ref = options || {},\n      _ref$atBegin = _ref.atBegin,\n      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\n\n  return throttle(delay, callback, {\n    debounceMode: atBegin !== false\n  });\n}\n\nexports.debounce = debounce;\nexports.throttle = throttle;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvY2pzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHlCQUF5Qjs7QUFFekIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw4RUFBOEUsYUFBYTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm90dGxlLWRlYm91bmNlL2Nqcy9pbmRleC5qcz8zNzRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xuXG4vKipcbiAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xuICogZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtICAgICAgICAgICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBtb3N0IHVzZWZ1bC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gICAgICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcy1pcywgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gICAgICAgICAgICAgIEFuIG9iamVjdCB0byBjb25maWd1cmUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9UcmFpbGluZ10gLSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGZpbmFsIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9MZWFkaW5nXSAtICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub0xlYWRpbmcgaXMgZmFsc2UsIHRoZSBmaXJzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbCB3aWxsIGV4ZWN1dGUgY2FsbGJhY2tcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseS4gSWYgbm9MZWFkaW5nIGlzIHRydWUsIHRoZSBmaXJzdCB0aGUgY2FsbGJhY2sgZXhlY3V0aW9uIHdpbGwgYmUgc2tpcHBlZC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayB3aWxsIG5ldmVyIGV4ZWN1dGVkIGlmIGJvdGggbm9MZWFkaW5nID0gdHJ1ZSBhbmQgbm9UcmFpbGluZyA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlYm91bmNlTW9kZV0gLSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0aHJvdHRsZSAoZGVsYXksIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgIF9yZWYkbm9UcmFpbGluZyA9IF9yZWYubm9UcmFpbGluZyxcbiAgICAgIG5vVHJhaWxpbmcgPSBfcmVmJG5vVHJhaWxpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRub1RyYWlsaW5nLFxuICAgICAgX3JlZiRub0xlYWRpbmcgPSBfcmVmLm5vTGVhZGluZyxcbiAgICAgIG5vTGVhZGluZyA9IF9yZWYkbm9MZWFkaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbm9MZWFkaW5nLFxuICAgICAgX3JlZiRkZWJvdW5jZU1vZGUgPSBfcmVmLmRlYm91bmNlTW9kZSxcbiAgICAgIGRlYm91bmNlTW9kZSA9IF9yZWYkZGVib3VuY2VNb2RlID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmJGRlYm91bmNlTW9kZTtcbiAgLypcbiAgICogQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcbiAgICogYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXG4gICAqIGRlYm91bmNlIG1vZGVzLlxuICAgKi9cblxuXG4gIHZhciB0aW1lb3V0SUQ7XG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxuXG4gIHZhciBsYXN0RXhlYyA9IDA7IC8vIEZ1bmN0aW9uIHRvIGNsZWFyIGV4aXN0aW5nIHRpbWVvdXRcblxuICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcbiAgICBpZiAodGltZW91dElEKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICB9XG4gIH0gLy8gRnVuY3Rpb24gdG8gY2FuY2VsIG5leHQgZXhlY1xuXG5cbiAgZnVuY3Rpb24gY2FuY2VsKG9wdGlvbnMpIHtcbiAgICB2YXIgX3JlZjIgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBfcmVmMiR1cGNvbWluZ09ubHkgPSBfcmVmMi51cGNvbWluZ09ubHksXG4gICAgICAgIHVwY29taW5nT25seSA9IF9yZWYyJHVwY29taW5nT25seSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiR1cGNvbWluZ09ubHk7XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuICAgIGNhbmNlbGxlZCA9ICF1cGNvbWluZ09ubHk7XG4gIH1cbiAgLypcbiAgICogVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xuICAgKiBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxuICAgKiBpcyBleGVjdXRlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNfID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJndW1lbnRzX1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RFeGVjYCB0aW1lc3RhbXAuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XG4gICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHNfKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFub0xlYWRpbmcgJiYgZGVib3VuY2VNb2RlICYmICF0aW1lb3V0SUQpIHtcbiAgICAgIC8qXG4gICAgICAgKiBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcbiAgICAgICAqIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgZXhlY3V0ZSBgY2FsbGJhY2tgXG4gICAgICAgKiBhbmQgbm9MZWFkaW5nICE9IHRydWUuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoKTtcbiAgICB9XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXG4gICAgaWYgKGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xuICAgICAgaWYgKG5vTGVhZGluZykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlIHdpdGggbm9MZWFkaW5nLCBpZiBgZGVsYXlgIHRpbWUgaGFzXG4gICAgICAgICAqIGJlZW4gZXhjZWVkZWQsIHVwZGF0ZSBgbGFzdEV4ZWNgIGFuZCBzY2hlZHVsZSBgY2FsbGJhY2tgXG4gICAgICAgICAqIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAgICovXG4gICAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAoIW5vVHJhaWxpbmcpIHtcbiAgICAgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlIHdpdGhvdXQgbm9MZWFkaW5nLCBpZiBgZGVsYXlgIHRpbWUgaGFzIGJlZW4gZXhjZWVkZWQsIGV4ZWN1dGVcbiAgICAgICAgICogYGNhbGxiYWNrYC5cbiAgICAgICAgICovXG4gICAgICAgIGV4ZWMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vVHJhaWxpbmcgIT09IHRydWUpIHtcbiAgICAgIC8qXG4gICAgICAgKiBJbiB0cmFpbGluZyB0aHJvdHRsZSBtb2RlLCBzaW5jZSBgZGVsYXlgIHRpbWUgaGFzIG5vdCBiZWVuXG4gICAgICAgKiBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuICAgICAgICogcmVjZW50IGV4ZWN1dGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxuICAgICAgICogYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuICAgICAgICogZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICovXG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgPyBkZWxheSAtIGVsYXBzZWQgOiBkZWxheSk7XG4gICAgfVxuICB9XG5cbiAgd3JhcHBlci5jYW5jZWwgPSBjYW5jZWw7IC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cblxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG4vKipcbiAqIERlYm91bmNlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBEZWJvdW5jaW5nLCB1bmxpa2UgdGhyb3R0bGluZyxcbiAqIGd1YXJhbnRlZXMgdGhhdCBhIGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgYSBzaW5nbGUgdGltZSwgZWl0aGVyIGF0IHRoZVxuICogdmVyeSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgY2FsbHMsIG9yIGF0IHRoZSB2ZXJ5IGVuZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSAgICAgICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIGRlYm91bmNlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSAgICAgICAgICAgQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdEJlZ2luXSAtICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIGF0QmVnaW4gaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuIElmIGF0QmVnaW4gaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmx5IGF0IHRoZSBmaXJzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLCB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldCkuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlYm91bmNlIChkZWxheSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgX3JlZiRhdEJlZ2luID0gX3JlZi5hdEJlZ2luLFxuICAgICAgYXRCZWdpbiA9IF9yZWYkYXRCZWdpbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGF0QmVnaW47XG5cbiAgcmV0dXJuIHRocm90dGxlKGRlbGF5LCBjYWxsYmFjaywge1xuICAgIGRlYm91bmNlTW9kZTogYXRCZWdpbiAhPT0gZmFsc2VcbiAgfSk7XG59XG5cbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/throttle-debounce/cjs/index.js\n"));

/***/ })

}]);